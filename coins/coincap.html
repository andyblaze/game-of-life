<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>CoinCap Animation Loop</title>
<style>
body {
    font-family: monospace;
    background: #000000;
    color: #ffffff;
    padding: 0;
    margin:0;
}
#onscreen {
    display:block; width:100vw; height:100vh;
}
</style>
</head>
<body>
<canvas id="onscreen"></canvas>
<script>
const canvas = document.getElementById("onscreen");
function resizeCanvas() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    onscreen.width  = Math.round(window.innerWidth * dpr);
    onscreen.height = Math.round(window.innerHeight * dpr);
    onscreen.style.width  = window.innerWidth + 'px';
    onscreen.style.height = window.innerHeight + 'px';  
}
class DataCollector {
    constructor(url) {
        this.url = url;
        this.data = null;
        this.token = "88432dce8cf1a1b5c01fa87a87d541f6d6a42f86fad5c4c226eddbd41854d4fb";
    }
    async fetchData() {
        try {
            const response = await fetch(this.url, {
                method: "GET",
                headers: {
                    "Authorization": `Bearer ${this.token}`,
                    "Accept": "application/json"
                }
            });
            if ( ! response.ok ) throw new Error(`HTTP ${response.status}`);
            const json = await response.json();
            this.data = json;
            //console.log("Fetched data:", json);
            return json;
        } catch (err) {
            //console.error("Fetch error:", err);
            return null;
        }
    }
}

class AnimationController {
    constructor(collector, processor, fetchIntervalSeconds = 5) {
        this.collector = collector;
        this.processor = processor;
        this.frame = 0;
        this.fps = 60;
        this.fetchIntervalFrames = fetchIntervalSeconds * this.fps;

        this.lastFetchFrame = -this.fetchIntervalFrames; // force immediate fetch
    }
    async start() {
        await this.collector.fetchData();
        this.loop();
    }
    async loop() {
        this.frame++;
        // Trigger fetch every N seconds
        if ( this.frame - this.lastFetchFrame >= this.fetchIntervalFrames ) {
            this.lastFetchFrame = this.frame;
            const data = await this.collector.fetchData();
            if (data) 
                this.processor.process(data);
        }
        requestAnimationFrame(() => this.loop());
    }
}

class OrbitProcessor {
    transform(data) {
        return Object.entries(data).map(([symbol, coin]) => {
            const toNum = (v) => (v != null && !isNaN(v)) ? Number(v) : 0;

            const price = toNum(coin.priceUsd);
            const radius = Math.max(5, Math.log10(price || 1) * 5);

            return {
                symbol,
                id: coin.id,
                priceUsd: price,
                supply: toNum(coin.supply),
                maxSupply: coin.maxSupply ? toNum(coin.maxSupply) : null,
                marketCapUsd: toNum(coin.marketCapUsd),
                volumeUsd24Hr: toNum(coin.volumeUsd24Hr),
                changePercent24Hr: toNum(coin.changePercent24Hr),
                vwap24Hr: toNum(coin.vwap24Hr),
                radius
            };
        });
    }
}

class DefaultRenderer {
    draw(ctx, data) {
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        data.forEach((coin, i) => {
            // simple grid layout
            const cols = 10;
            const spacingX = ctx.canvas.width / cols;
            const spacingY = 80;
            const x = (i % cols) * spacingX + spacingX / 2;
            const y = Math.floor(i / cols) * spacingY + spacingY / 2;

            ctx.beginPath();
            // radius based on processed value
            ctx.arc(x, y, coin.radius, 0, Math.PI * 2);
            ctx.fillStyle = "limegreen";
            ctx.fill();

            // optional: label
            ctx.fillStyle = "#ffffff";
            ctx.font = "14px monospace";
            ctx.textAlign = "center";
            ctx.fillText(coin.symbol, x, y + coin.radius + 12);
        });
    }
}

class Processor {
    constructor(strategy, renderer) {
        this.strategy = strategy;
        this.renderer = renderer;
    }

    process(rawData) { 
        const processed = this.strategy.transform(rawData.data);
        this.renderer.render(processed);
    }
}

class Renderer {
    constructor(canvas, strategy) {
        this.canvas = canvas;
        this.ctx = this.canvas.getContext('2d');
        this.strategy = strategy;
    }
    render(data) {
        this.strategy.draw(this.ctx, data);
    }
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();
const config = {
    dataUrl: "http://127.0.0.1/gol/coins/data.php",
    dataPollInterval: 3 // seconds
};
// Instantiate
const processor = new Processor(
    new OrbitProcessor(),
    new Renderer(canvas, new DefaultRenderer())
);
const collector = new DataCollector(config.dataUrl);
const controller = new AnimationController(collector, processor, config.dataPollInterval); 
controller.start();
</script>
</body>
</html>
