<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>CoinCap Animation Loop</title>
<style>
body {
    font-family: monospace;
    background: #000000;
    color: #ffffff;
    padding: 0;
    margin:0;
}
#onscreen {
    display:block; width:100vw; height:100vh;
}
</style>
</head>
<body>
<canvas id="onscreen"></canvas>
<script>
const canvas = document.getElementById("onscreen");
function resizeCanvas() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const sz = { w: window.innerWidth, h: window.innerHeight };
    onscreen.width  = Math.round(sz.w * dpr);
    onscreen.height = Math.round(sz.h * dpr);
    onscreen.style.width  = sz.w + "px";
    onscreen.style.height = sz.h + "px";  
}
class DataCollector {
    constructor(url) {
        this.url = url;
        this.data = null;
        this.token = "88432dce8cf1a1b5c01fa87a87d541f6d6a42f86fad5c4c226eddbd41854d4fb";
    }
    async fetchData() {
        try {
            const response = await fetch(this.url, {
                method: "GET",
                headers: {
                    "Authorization": `Bearer ${this.token}`,
                    "Accept": "application/json"
                }
            });
            if ( ! response.ok ) throw new Error(`HTTP ${response.status}`);
            const json = await response.json();
            this.data = json;
            //console.log("Fetched data:", json);
            return json;
        } catch (err) {
            //console.error("Fetch error:", err);
            return null;
        }
    }
}

class AnimationController {
    constructor(collector, processor, fetchIntervalSeconds = 5) {
        this.collector = collector;
        this.processor = processor;
        this.frame = 0;
        this.fps = 60;
        this.fetchIntervalFrames = fetchIntervalSeconds * this.fps;

        this.lastFetchFrame = -this.fetchIntervalFrames; // force immediate fetch
    }
    async start() {
        await this.collector.fetchData();
        this.loop();
    }
    async loop() {
        this.frame++;
        // Trigger fetch every N seconds
        if ( this.frame - this.lastFetchFrame >= this.fetchIntervalFrames ) {
            this.lastFetchFrame = this.frame;
            const data = await this.collector.fetchData();
            if (data) 
                this.processor.process(data);
        }
        requestAnimationFrame(() => this.loop());
    }
}

class OrbitProcessor {
    transform(data) {
        return Object.entries(data).map(([symbol, coin], index) => {
            const toNum = (v) => (v != null && !isNaN(v)) ? Number(v) : 0;

            const price = toNum(coin.priceUsd);
            const marketCap = toNum(coin.marketCapUsd);
            const change = toNum(coin.changePercent24Hr);

            // --- Derived render parameters ---
            const radius = Math.max(4, Math.log10(price || 1) * 5);
            // Orbit distance based on rank or market cap (spread out visually)
            const orbitRadius = Math.log10(marketCap + 1) * 15 + (index * 4);
            // Speed: more volatile coins orbit faster
            const orbitSpeed = 0.001 + Math.abs(change) * 0.00005;
            // Random start angle to distribute around circle
            const angle = Math.random() * Math.PI * 2;
            // Color hint: green for positive, red for negative
            const color = change >= 0 ? '#5f5' : '#f55';

            return {
                symbol,
                id: coin.id,
                priceUsd: price,
                supply: toNum(coin.supply),
                maxSupply: coin.maxSupply ? toNum(coin.maxSupply) : null,
                marketCapUsd: marketCap,
                volumeUsd24Hr: toNum(coin.volumeUsd24Hr),
                changePercent24Hr: change,
                vwap24Hr: toNum(coin.vwap24Hr),

                // --- orbital render properties ---
                radius,
                orbitRadius,
                orbitSpeed,
                angle,
                color
            };
        });
    }
}


class OrbitRenderer {
    constructor() {
        this.center = null;
    }
    circle(ctx, x, y, r, color) {
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();
    }
    draw(ctx, data) {
        const { width, height } = ctx.canvas;
        ctx.clearRect(0, 0, width, height);

        if (!data.length) return;

        // Establish center and max radius we can draw within
        const minDimension = Math.min(width, height);
        const maxAllowedRadius = minDimension * 0.45; // 90% diameter use

        this.center = { x: width / 2, y: height / 2 };
        // Find current max orbit radius among data
        const maxOrbit = Math.max(...data.map(c => c.orbitRadius));
        // Compute a scaling factor to fit all orbits on screen
        const scale = maxOrbit > 0 ? maxAllowedRadius / maxOrbit : 1;

        // Draw central "sun"
        this.circle(ctx, this.center.x, this.center.y, 8, "#ffaa00")

        // Draw each coin
        data.forEach(coin => {
            // Apply scale
            const orbitR = coin.orbitRadius * scale;
            // Update angle
            coin.angle += coin.orbitSpeed;
            // Compute position
            const x = this.center.x + Math.cos(coin.angle) * orbitR;
            const y = this.center.y + Math.sin(coin.angle) * orbitR;
            // Optional orbit path
            /*ctx.beginPath();
            ctx.arc(this.center.x, this.center.y, orbitR, 0, Math.PI * 2);
            ctx.strokeStyle = "rgba(255,255,255,0.05)";
            ctx.lineWidth = 1;
            ctx.stroke();*/

            // Planet
            this.circle(ctx, x, y, coin.radius, coin.color || "#0f0");
            // Label
            ctx.fillStyle = "#ccc";
            ctx.font = "12px monospace";
            ctx.textAlign = "center";
            ctx.fillText(coin.symbol, x, y + coin.radius + 12);
        });
    }
}

class Processor {
    constructor(strategy, renderer) {
        this.strategy = strategy;
        this.renderer = renderer;
    }

    process(rawData) { 
        const processed = this.strategy.transform(rawData.data);
        this.renderer.render(processed);
    }
}

class Renderer {
    constructor(canvas, strategy) {
        this.canvas = canvas;
        this.ctx = this.canvas.getContext('2d');
        this.strategy = strategy;
    }
    render(data) {
        this.strategy.draw(this.ctx, data);
    }
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();
const config = {
    dataUrl: "http://127.0.0.1/gol/coins/data.php",
    dataPollInterval: 3 // seconds
};
// Instantiate
const processor = new Processor(
    new OrbitProcessor(),
    new Renderer(canvas, new OrbitRenderer())
);
const collector = new DataCollector(config.dataUrl);
const controller = new AnimationController(collector, processor, config.dataPollInterval); 
controller.start();
</script>
</body>
</html>
