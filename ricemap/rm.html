<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rice Grain Map — Interactive</title>
  <style>
    :root{ --bg:#0f1724; --panel:#0b1220; --accent:#f59e0b; --muted:#94a3b8 }
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial}
    body{display:flex;gap:12px;padding:12px;background:linear-gradient(180deg,#071028 0%, #0b1220 100%);color:#e6eef8}
    .controls{width:320px;min-width:240px;padding:14px;border-radius:12px;background:linear-gradient(180deg,var(--panel),#071223);box-shadow:0 6px 20px rgba(2,6,23,.6)}
    h1{font-size:18px;margin:0 0 8px;color:var(--accent)}
    label{display:block;font-size:12px;color:var(--muted);margin-top:8px}
    button, input[type=range], select{width:100%;margin-top:6px}
    button{padding:8px;border-radius:8px;border:0;background:var(--accent);color:#071022;font-weight:600;cursor:pointer}
    canvas{border-radius:8px;background:linear-gradient(180deg,#f8fafc 0%, #edf2f7 100%);box-shadow:0 10px 30px rgba(2,6,23,.5);display:block}
    .small{font-size:12px;color:var(--muted)}
    .row{display:flex;gap:8px}
    .row > *{flex:1}
    .hint{font-size:12px;color:var(--muted);margin-top:8px}
    .footer{font-size:12px;color:var(--muted);margin-top:10px}
  </style>
</head>
<body>
  <div class="controls">
    <h1>Rice Grain Map — Interactive</h1>
    <div class="small">Simulate rice, swirl it, trace coastline, color terrain, add towns, export PNG.</div>

    <label>Canvas size</label>
    <select id="sizeSelect">
      <option value="800">800 × 600</option>
      <option value="1200">1200 × 900</option>
      <option value="1600">1600 × 1200</option>
    </select>

    <label>Grain count: <span id="countLabel">1200</span></label>
    <input id="countRange" type="range" min="200" max="4000" step="50" value="1200">

    <label>Grain size: <span id="gs">2.6</span> px</label>
    <input id="grainSize" type="range" min="1" max="6" step="0.1" value="2.6">

    <div style="margin-top:10px" class="row">
      <button id="scatterBtn">Scatter Rice</button>
      <button id="randomizeBtn">Randomize</button>
    </div>

    <label>Swirl intensity: <span id="si">1.0</span></label>
    <input id="swirlRange" type="range" min="0" max="5" step="0.1" value="1">
    <div class="small hint">Click and drag on canvas to apply a stronger local swirl.</div>

    <div class="row" style="margin-top:8px">
      <button id="swirlBtn">Auto Swirl (10 iters)</button>
      <button id="relaxBtn">Relax (smooth)</button>
    </div>

    <div class="row" style="margin-top:8px">
      <button id="traceBtn">Trace Outline</button>
      <button id="fillBtn">Fill & Remove Rice</button>
    </div>

    <label>Contour grid step (lower = finer)</label>
    <input id="gridStep" type="range" min="1" max="8" step="1" value="3">

    <div class="row" style="margin-top:8px">
      <button id="colorizeBtn">Colorize Terrain</button>
      <button id="labelsBtn">Toggle Labels</button>
    </div>

    <div class="row" style="margin-top:8px">
      <button id="addTownBtn">Add Town (click map)</button>
      <button id="exportBtn">Export PNG</button>
    </div>

    <div class="footer">Tips: drag to swirl; use <b>Trace</b> then <b>Fill</b>; click <b>Add Town</b> then click canvas.</div>
  </div>

  <div style="flex:1;display:flex;flex-direction:column;gap:8px;align-items:center">
    <canvas id="mainCanvas" width="800" height="600"></canvas>
    <div style="width:100%;max-width:1200px;display:flex;justify-content:space-between;color:var(--muted)">
      <div id="status">Ready</div>
      <div class="small">Inspired by rice-grain fantasy maps</div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('mainCanvas');
  const ctx = canvas.getContext('2d');
  const off = document.createElement('canvas');
  const offCtx = off.getContext('2d');

  // DOM
  const scatterBtn = document.getElementById('scatterBtn');
  const randomizeBtn = document.getElementById('randomizeBtn');
  const swirlBtn = document.getElementById('swirlBtn');
  const relaxBtn = document.getElementById('relaxBtn');
  const traceBtn = document.getElementById('traceBtn');
  const fillBtn = document.getElementById('fillBtn');
  const colorizeBtn = document.getElementById('colorizeBtn');
  const exportBtn = document.getElementById('exportBtn');
  const addTownBtn = document.getElementById('addTownBtn');
  const labelsBtn = document.getElementById('labelsBtn');
  const sizeSelect = document.getElementById('sizeSelect');
  const countRange = document.getElementById('countRange');
  const countLabel = document.getElementById('countLabel');
  const grainSize = document.getElementById('grainSize');
  const gsLabel = document.getElementById('gs');
  const swirlRange = document.getElementById('swirlRange');
  const siLabel = document.getElementById('si');
  const gridStep = document.getElementById('gridStep');

  // state
  let grains = [];
  let towns = [];
  let labelsOn = true;
  let addingTown = false;
  let outlinePolygons = [];
  let filledShape = null; // polygon

  function setSize(px){
    const w = px; const h = Math.round(px * 0.75);
    canvas.width = w; canvas.height = h;
    off.width = w; off.height = h;
    draw();
  }

  sizeSelect.addEventListener('change', e=> setSize(Number(e.target.value)));
  countRange.addEventListener('input', ()=>{ countLabel.textContent = countRange.value; });
  grainSize.addEventListener('input', ()=>{ gsLabel.textContent = grainSize.value; draw(); });
  swirlRange.addEventListener('input', ()=>{ siLabel.textContent = swirlRange.value; });

  // utilities
  function rand(min,max){ return Math.random()*(max-min)+min }
  function distance(a,b){ return Math.hypot(a.x-b.x,a.y-b.y) }

  function scatter(n){
    grains = [];
    // allow a bit of margin; prefer central clustering to make island-like
    for(let i=0;i<n;i++){
      // generate with radial bias so islands form
      const cx = canvas.width/2; const cy = canvas.height/2;
      const r = Math.sqrt(Math.random()) * Math.min(cx,cy) * 0.9; // sqrt for central density
      const ang = Math.random()*Math.PI*2;
      const x = cx + Math.cos(ang)*r + rand(-20,20);
      const y = cy + Math.sin(ang)*r + rand(-20,20);
      grains.push({x,y,ang:Math.random()*Math.PI*2,sz:parseFloat(grainSize.value) + Math.random()*0.6 - 0.3});
    }
    outlinePolygons = []; filledShape = null; towns = [];
    draw();
  }

  function drawGrains(ctxUse){
    ctxUse.clearRect(0,0,canvas.width,canvas.height);
    // subtle background
    ctxUse.fillStyle = '#f8fafc';
    ctxUse.fillRect(0,0,canvas.width,canvas.height);
    // draw grains
    ctxUse.save();
    ctxUse.translate(0,0);
    for(const g of grains){
      ctxUse.beginPath();
      ctxUse.ellipse(g.x,g.y,g.sz*1.2,g.sz, g.ang, 0, Math.PI*2);
      ctxUse.fillStyle = '#e6d8bf';
      ctxUse.fill();
      ctxUse.strokeStyle = 'rgba(0,0,0,0.06)';
      ctxUse.stroke();
    }
    ctxUse.restore();
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    if(grains.length) drawGrains(ctx);
    // if filled polygon present, draw it on top
    if(filledShape){
      // draw base terrain
      ctx.save();
      ctx.beginPath();
      drawPolygonPath(ctx, filledShape);
      ctx.fillStyle = '#c9e6c6';
      ctx.fill();
      ctx.strokeStyle = '#1f2937'; ctx.lineWidth = 2; ctx.stroke();
      ctx.restore();
    }
    // draw outline polygons on top if exist
    if(outlinePolygons.length){
      ctx.save(); ctx.strokeStyle = 'rgba(0,0,0,0.6)'; ctx.lineWidth = 1.6;
      for(const poly of outlinePolygons){ ctx.beginPath(); drawPolygonPath(ctx, poly); ctx.stroke(); }
      ctx.restore();
    }
    // draw towns
    for(const t of towns){ drawTown(ctx,t); }
  }

  function drawTown(context,t){
    context.save();
    context.beginPath(); context.arc(t.x,t.y,6,0,Math.PI*2); context.fillStyle='#27272a'; context.fill();
    context.beginPath(); context.arc(t.x,t.y,3,0,Math.PI*2); context.fillStyle='#fef3c7'; context.fill();
    if(labelsOn){ context.font='bold 14px serif'; context.fillStyle='#08132a'; context.fillText(t.label, t.x+10, t.y-6); }
    context.restore();
  }

  // --- Swirl / perturbation
  function applySwirl(center, intensity, iterations=1){
    for(let it=0; it<iterations; it++){
      for(const g of grains){
        const dx = g.x - center.x; const dy = g.y - center.y;
        const dist = Math.hypot(dx,dy) + 0.0001;
        // rotation amount decreases with distance
        const angle = (intensity / dist) * 0.8; // tweak
        const s = Math.sin(angle), c = Math.cos(angle);
        const nx = dx*c - dy*s; const ny = dx*s + dy*c;
        g.x = center.x + nx + rand(-0.6,0.6);
        g.y = center.y + ny + rand(-0.6,0.6);
        g.ang += angle*0.3;
        // nudges towards center for cohesion
        g.x += (canvas.width/2 - g.x) * 0.001;
        g.y += (canvas.height/2 - g.y) * 0.001;
      }
    }
    draw();
  }

  // relax: simple smoothing: move grains slightly towards average of neighbours
  function relax(iter=1){
    for(let it=0; it<iter; it++){
      // create spatial grid
      const k = 12; // neighborhood radius
      const newpos = [];
      for(let i=0;i<grains.length;i++){
        const g = grains[i];
        let sx=0, sy=0, c=0;
        for(let j=0;j<grains.length;j++){
          const h = grains[j]; const d = Math.hypot(g.x-h.x,g.y-h.y);
          if(d>0 && d<k){ sx+=h.x; sy+=h.y; c++; }
        }
        if(c>0){ newpos.push({x: g.x*0.7 + (sx/c)*0.3, y: g.y*0.7 + (sy/c)*0.3, ang:g.ang}); }
        else newpos.push(g);
      }
      grains = newpos;
    }
    draw();
  }

  // --- Contour extraction via marching squares on occupancy grid ---
  function extractContours(step=3, threshold=1){
    // render grains to offscreen in black
    offCtx.clearRect(0,0,off.width,off.height);
    offCtx.fillStyle = '#fff'; offCtx.fillRect(0,0,off.width,off.height);
    offCtx.fillStyle = '#000';
    for(const g of grains){ offCtx.beginPath(); offCtx.ellipse(g.x,g.y,g.sz*1.4,g.sz*1.1,g.ang,0,Math.PI*2); offCtx.fill(); }
    const W = off.width, H = off.height;
    const cols = Math.ceil(W/step)+1; const rows = Math.ceil(H/step)+1;
    // sample grid
    const grid = new Array(rows);
    const img = offCtx.getImageData(0,0,W,H).data;
    for(let r=0;r<rows;r++){
      grid[r]=new Array(cols);
      for(let c=0;c<cols;c++){
        const x = Math.min(Math.round(c*step), W-1); const y = Math.min(Math.round(r*step), H-1);
        const idx = (y*W + x)*4;
        const val = img[idx]; // 0 black, 255 white
        grid[r][c] = (val < 250) ? 1 : 0;
      }
    }
    // marching squares
    const contours = [];
    const visited = new Set();
    function key(rr,cc){return rr+','+cc}

    function march(startR,startC){
      const path = [];
      let r=startR, c=startC; let dir=0; // 0:right,1:down,2:left,3:up
      // limit steps
      for(let stepCount=0; stepCount<20000; stepCount++){
        const a = grid[r][c]; const b = grid[r][c+1] || 0; const d = grid[r+1] ? grid[r+1][c] : 0; const e = grid[r+1] ? grid[r+1][c+1] : 0;
        const state = (a<<3) | (b<<2) | (e<<1) | d; // custom orientation
        // use simple decisions to trace boundary between 0/1
        // map state to next offset
        let moved=false;
        // checks in order to follow boundary
        const moves = [
          {cond: state===1, dr:1, dc:0},
          {cond: state===3, dr:0, dc:1},
          {cond: state===2, dr:0, dc:1},
          {cond: state===6, dr:-1, dc:0},
          {cond: state===4, dr:0, dc:-1},
          {cond: state===12, dr:0, dc:-1},
          {cond: state===8, dr:1, dc:0},
          {cond: state===9, dr:1, dc:0},
        ];
        for(const m of moves){ if(m.cond){ r+=m.dr; c+=m.dc; path.push([c*step, r*step]); moved=true; break;} }
        if(!moved) break;
        const kk = key(r,c);
        if(visited.has(kk)) break;
        visited.add(kk);
      }
      return path;
    }

    for(let r=0;r<rows-1;r++){
      for(let c=0;c<cols-1;c++){
        if(grid[r][c]===1 && grid[r][c+1]===0){
          const p = march(r,c);
          if(p && p.length>4) contours.push(p);
        }
      }
    }

    // fallback: if contours empty, create convex hull of grains
    if(contours.length===0 && grains.length){
      const pts = grains.map(g=>({x:g.x,y:g.y}));
      const hull = convexHull(pts);
      return [hull.map(p=>[p.x,p.y])];
    }
    return contours;
  }

  // draw polygon path helper
  function drawPolygonPath(ctxp, poly){
    if(!poly || poly.length===0) return;
    ctxp.moveTo(poly[0][0], poly[0][1]);
    for(let i=1;i<poly.length;i++) ctxp.lineTo(poly[i][0], poly[i][1]);
    ctxp.closePath();
  }

  // convex hull (Andrew monotone)
  function convexHull(points){
    const pts = points.map(p=>[p.x,p.y]).sort((a,b)=>a[0]-b[0]||a[1]-b[1]);
    if(pts.length<=3) return pts.map(p=>({x:p[0],y:p[1]}));
    function cross(o,a,b){ return (a[0]-o[0])*(b[1]-o[1]) - (a[1]-o[1])*(b[0]-o[0]); }
    const lower=[]; for(const p of pts){ while(lower.length>=2 && cross(lower[lower.length-2], lower[lower.length-1], p) <= 0) lower.pop(); lower.push(p); }
    const upper=[]; for(let i=pts.length-1;i>=0;i--){ const p=pts[i]; while(upper.length>=2 && cross(upper[upper.length-2], upper[upper.length-1], p) <= 0) upper.pop(); upper.push(p); }
    upper.pop(); lower.pop(); const hull = lower.concat(upper).map(p=>({x:p[0],y:p[1]})); return hull;
  }

  // simple polygon simplifier (Ramer–Douglas–Peucker)
  function simplify(points, epsilon){
    if(points.length<3) return points;
    const sqr = (a)=>a*a;
    function perpDist(pt, a, b){
      const A = pt[0]-a[0], B = pt[1]-a[1]; const C = b[0]-a[0], D = b[1]-a[1];
      const dot = A*C + B*D; const len2 = C*C + D*D; const t = Math.max(0, Math.min(1, dot/len2));
      const projx = a[0] + t*C, projy = a[1] + t*D; return Math.hypot(pt[0]-projx, pt[1]-projy);
    }
    function rdp(pts){
      let dmax=0, idx=0;
      for(let i=1;i<pts.length-1;i++){ const d = perpDist(pts[i], pts[0], pts[pts.length-1]); if(d>dmax){ idx=i; dmax=d; }}
      if(dmax > epsilon){ const left = rdp(pts.slice(0, idx+1)); const right = rdp(pts.slice(idx)); return left.slice(0,-1).concat(right); } else return [pts[0], pts[pts.length-1]];
    }
    return rdp(points);
  }

  // fill polygon (choose largest contour)
  function fillContours(contours){
    if(contours.length===0) return;
    // choose largest by area
    function area(poly){ let a=0; for(let i=0;i<poly.length;i++){ const j=(i+1)%poly.length; a += poly[i][0]*poly[j][1] - poly[j][0]*poly[i][1]; } return Math.abs(a)/2; }
    contours.sort((a,b)=>area(b)-area(a));
    const poly = contours[0];
    // simplify
    const simp = simplify(poly, 2.2);
    outlinePolygons = [simp];
    filledShape = simp;
    grains = []; // remove rice
    draw();
  }

  // colorize by simple distance transform from coast to center -> elevation
  function colorizeTerrain(){
    if(!filledShape) return;
    // compute bounding box
    const img = ctx.getImageData(0,0,canvas.width,canvas.height);
    // we'll paint the island with a radial gradient from shore to center
    // compute center of polygon
    let cx=0, cy=0; for(const p of filledShape){ cx += p[0]; cy += p[1]; } cx/=filledShape.length; cy/=filledShape.length;
    // create mask
    const mask = new Uint8ClampedArray(canvas.width * canvas.height);
    const poly = filledShape;
    function pointInPoly(x,y){ let inside=false; for(let i=0,j=poly.length-1;i<poly.length;j=i++){ const xi=poly[i][0], yi=poly[i][1]; const xj=poly[j][0], yj=poly[j][1]; const intersect = ((yi>y)!=(yj>y)) && (x < (xj-xi)*(y-yi)/(yj-yi)+xi); if(intersect) inside=!inside; } return inside; }
    for(let y=0;y<canvas.height;y++){
      for(let x=0;x<canvas.width;x++){
        if(pointInPoly(x+0.5,y+0.5)) mask[y*canvas.width + x] = 1;
      }
    }
    // compute distance to coast by BFS from boundary
    const dist = new Float32Array(canvas.width * canvas.height).fill(Infinity);
    const q = [];
    for(let y=0;y<canvas.height;y++){
      for(let x=0;x<canvas.width;x++){
        const i = y*canvas.width + x;
        if(mask[i]){
          // check if any neighbor is outside
          const outside = (x===0||y===0||x===canvas.width-1||y===canvas.height-1) || mask[i-1]===0 || mask[i+1]===0 || mask[i-canvas.width]===0 || mask[i+canvas.width]===0;
          if(outside){ dist[i]=0; q.push(i); }
        }
      }
    }
    const w = canvas.width;
    while(q.length){
      const cur = q.shift(); const y = Math.floor(cur/w), x = cur%w; const cd = dist[cur];
      const neigh = [ [x-1,y],[x+1,y],[x,y-1],[x,y+1] ];
      for(const [nx,ny] of neigh){ if(nx>=0&&nx<w&&ny>=0&&ny<canvas.height){ const ni = ny*w + nx; if(mask[ni] && dist[ni] > cd+1){ dist[ni] = cd+1; q.push(ni); } }}
    }
    // find max
    let maxd = 0; for(let i=0;i<dist.length;i++) if(dist[i]<Infinity && dist[i]>maxd) maxd=dist[i];
    // paint
    const out = ctx.createImageData(canvas.width, canvas.height);
    for(let y=0;y<canvas.height;y++){
      for(let x=0;x<canvas.width;x++){
        const i = y*canvas.width + x; const j = i*4;
        if(mask[i]){
          const t = dist[i]/(maxd||1);
          // t=0 at coast -> sand color; t=1 at center -> mountain/grass
          const r = Math.round(240*(1-t) + 60*(t));
          const g = Math.round(220*(1-t) + 120*(t));
          const b = Math.round(170*(1-t) + 80*(t));
          out.data[j] = r; out.data[j+1] = g; out.data[j+2] = b; out.data[j+3] = 255;
        } else {
          out.data[j]=245; out.data[j+1]=250; out.data[j+2]=255; out.data[j+3]=255;
        }
      }
    }
    ctx.putImageData(out,0,0);
    // draw outline & towns on top
    if(outlinePolygons.length){ ctx.save(); ctx.strokeStyle='#102226'; ctx.lineWidth=2; for(const poly of outlinePolygons){ ctx.beginPath(); drawPolygonPath(ctx, poly); ctx.stroke(); } ctx.restore(); }
    for(const t of towns) drawTown(ctx,t);
  }

  // --- events & interactions ---
  scatterBtn.addEventListener('click', ()=> scatter(Number(countRange.value)) );
  randomizeBtn.addEventListener('click', ()=> { // slight random move
    for(const g of grains){ g.x += rand(-30,30); g.y += rand(-30,30); }
    draw();
  });
  swirlBtn.addEventListener('click', ()=> applySwirl({x:canvas.width/2,y:canvas.height/2}, Number(swirlRange.value), 10));
  relaxBtn.addEventListener('click', ()=> relax(3));
  traceBtn.addEventListener('click', ()=>{
    const contours = extractContours(Number(gridStep.value));
    outlinePolygons = contours.map(p=>simplify(p,1.2));
    filledShape = null; draw();
    document.getElementById('status').textContent = 'Traced ' + outlinePolygons.length + ' contour(s)';
  });
  fillBtn.addEventListener('click', ()=>{
    const contours = extractContours(Number(gridStep.value));
    fillContours(contours);
    document.getElementById('status').textContent = 'Filled shape (rice removed)';
  });
  colorizeBtn.addEventListener('click', ()=>{ colorizeTerrain(); document.getElementById('status').textContent='Colorized terrain'; });
  exportBtn.addEventListener('click', ()=>{
    const a = document.createElement('a'); a.download = 'rice-map.png'; a.href = canvas.toDataURL('image/png'); a.click();
  });
  labelsBtn.addEventListener('click', ()=>{ labelsOn = !labelsOn; draw(); });

  addTownBtn.addEventListener('click', ()=>{ addingTown = true; document.getElementById('status').textContent='Click on map to add a town'; });

  canvas.addEventListener('click', (e)=>{
    const rect = canvas.getBoundingClientRect(); const x = (e.clientX - rect.left) * (canvas.width/rect.width); const y = (e.clientY - rect.top) * (canvas.height/rect.height);
    if(addingTown){ const name = prompt('Town name?', 'Newtown'); if(name){ towns.push({x,y,label:name}); draw(); } addingTown=false; document.getElementById('status').textContent='Town added'; return; }
  });

  // drag to swirl
  let dragging=false; let lastPos=null;
  canvas.addEventListener('pointerdown', (e)=>{ dragging=true; lastPos = getPos(e); canvas.setPointerCapture(e.pointerId); });
  canvas.addEventListener('pointerup', (e)=>{ dragging=false; lastPos=null; canvas.releasePointerCapture(e.pointerId); });
  canvas.addEventListener('pointermove', (e)=>{ if(!dragging) return; const p = getPos(e); const dx = p.x - lastPos.x, dy = p.y - lastPos.y; const center = p; const strength = Math.hypot(dx,dy) * Number(swirlRange.value) * 0.35; applySwirl(center, strength, 1); lastPos = p; });
  function getPos(e){ const rect = canvas.getBoundingClientRect(); return {x:(e.clientX-rect.left)*(canvas.width/rect.width), y:(e.clientY-rect.top)*(canvas.height/rect.height)} }

  // init
  setSize(800);
  scatter(1200);

})();
</script>
</body>
</html>
