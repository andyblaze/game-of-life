ODDS 

function fractionToText([n, d]) {
  if (n === 1 && d === 1) return "evens";
  if (n < d) return `${n} to ${d} on`;
  if (n > d) return `${n} to ${d}`;
  return `${n} to ${d}`;
}
function snapFraction(decimal) {
  const target = decimal - 1;
  let best = null;
  let bestDiff = Infinity;

  for (const [n, d] of FRACTIONAL_LADDER) {
    const value = n / d;
    const diff = Math.abs(value - target);
    if (diff < bestDiff) {
      bestDiff = diff;
      best = [n, d];
    }
  }

  return best;
}
const FRACTIONAL_LADDER = [
  [1, 4], [2, 7], [1, 3], [2, 5], [1, 2],
  [4, 7], [4, 6], [4, 5], [10, 11],
  [1, 1], // evens
  [6, 5], [5, 4], [4, 3], [11, 8],
  [6, 4], [7, 4], [2, 1],
  [9, 4], [5, 2], [3, 1],
  [4, 1], [5, 1], [6, 1],
  [8, 1], [10, 1], [12, 1]
];
function decimalToFraction(d) {
  const frac = d - 1;
  return { num: frac, den: 1 };
}
----------------------------------------------------------
class FormBook {  observers
  this.byDistance = new Map();
  this.byTrackDistance = new Map(); // `${trackId}:${distance}`
  this.byHorseTrack = new Map();
  this.bySeason = new Map();
}

getWinCount() {
  return this.history.filter(r => r.position === 1).length;
}

getAveragePosition() {
  if (this.history.length === 0) return null;
  const sum = this.history.reduce((a, r) => a + r.position, 0);
  return sum / this.history.length;
}

horses
  .slice()
  .sort((a, b) => a.getAveragePosition() - b.getAveragePosition())
  .slice(0, 10)
  .forEach(h => {
    console.log(
      `Horse ${h.id} avg pos: ${h.getAveragePosition().toFixed(2)} wins: ${h.getWinCount()}`
    );
  });

class Bookie {
  constructor(id) {
    this.id = id;
    this.models = {}; // horseId -> belief score
  }

  observeRace(results) {
    results.forEach((r, i) => {
      const hId = r.horse.id;
      if (!this.models[hId]) this.models[hId] = 0;
      this.models[hId] += (results.length - i); // reward finishing high
    });
  }

  getOdds(horseId) {
    const score = this.models[horseId] || 1;
    return 1 / score;
  }
}
