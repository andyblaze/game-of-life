<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<title>Binary stars â€” basic</title>
<style>
  html,body { height:100%; margin:0; background:#000; }
  canvas { display:block; width:100vw; height:100vh; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
/*
  Minimal binary-star orbit demo (no UI).
  - Two masses M1 and M2
  - Separation (pixels) and desired orbital period (seconds)
  - G is computed so the circular-orbit period ~ desiredPeriod
  - Leapfrog integrator (symplectic) used to advance the two-body system
  Tweak params below to experiment.
*/

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha: true });
const DPR = window.devicePixelRatio || 1;

function resize() {
    canvas.width = window.innerWidth * DPR;
    canvas.height = window.innerHeight * DPR;
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    // draw in CSS pixels (transform to account for DPR)
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
}
window.addEventListener('resize', resize);
resize();

// ---------- Simulation parameters (edit these) ----------
const params = {
    M1: 1.0,             // mass of star A (donor)
    M2: 2.4,             // mass of star B (accretor)
    separation: 260,     // separation between star centers in pixels
    desiredPeriod: 28.0,  // desired orbital period in seconds (used to pick G)
    softening: 1.0,      // gravitational softening in pixels (prevents singularity)
    visualScale: 4.0,     // world -> screen scale (pixels per world unit)
    eccentricity: 0.4  // 0 = circle, 0.4 = noticeable ellipse, <1
};
// -------------------------------------------------------

function Point(a, b) {
    return { "x": a, "y": b };
}

class Star {
    constructor(config) {
        this.cfg = config;
        this.m = config.m;
        this.pos = config.pos;
        this.vel = config.vel;
        this.radius = config.radius;
    } 
    worldToScreen(p){
        return Point(
            canvas.width / DPR * 0.5 + p.x * params.visualScale,
            canvas.height / DPR * 0.5 + p.y * params.visualScale
        );
    }
    draw(ctx, hue) {
        const screen = this.worldToScreen(this.pos);
        const r = Math.max(3, this.radius * params.visualScale);
        // small bright core
        ctx.fillStyle = `hsla(${hue},100%,70%,1)`;
        ctx.beginPath();
        ctx.arc(screen.x, screen.y, r * 0.8, 0, Math.PI * 2);
        ctx.fill();
    }
    setPos(p) {
        this.pos = p;
    }
    setVel(v) {
        this.vel = v;
    }
}

class Simulation {
    constructor(config) {
        this.cfg = config;
        this.gravity = 0;
        this.initBinary(config)
    }
    // compute G so that circular-orbit period equals desiredPeriod:
    // omega = 2*pi/T ; for circular orbit: omega^2 = G*(M1+M2)/a^3
    computeG(M1, M2, a, T) {
        const omega = 2 * Math.PI / T;
        this.gravity = Math.pow(a, 3) * omega * omega / (M1 + M2);
    }
    initBinary(cfg) {
        this.computeG(cfg.M1, cfg.M2, cfg.separation, cfg.desiredPeriod);
        const M1 = cfg.M1, M2 = this.cfg.M2;
        const a = cfg.separation;

        // center-of-mass at origin
        starA.setPos(Point(- (M2 / (M1 + M2)) * a, 0));
        starB.setPos(Point(+ (M1 / (M1 + M2)) * a, 0));

        // circular orbital velocity at this distance
        const vCirc = Math.sqrt(this.gravity * (M1 + M2) / a);

        // scale by eccentricity: treat initial position as apocenter
        const factor = Math.sqrt((1 - cfg.eccentricity) / (1 + cfg.eccentricity));
        const v = vCirc * factor;

        // assign velocities perpendicular to radius vector
        starA.setVel(Point(0, -v * (M2 / (M1 + M2))));
        starB.setVel(Point(0, +v * (M1 / (M1 + M2))));

        starA.m = M1; starB.m = M2;
        starA.radius = Math.max(6, 12 * Math.cbrt(M1));
        starB.radius = Math.max(5, 10 * Math.cbrt(M2));
    }
    // compute acceleration on 2 bodies (softened)
    accelOn(starA, starB) {
        const dx = starB.pos.x - starA.pos.x;
        const dy = starB.pos.y - starA.pos.y;
        const r2 = dx*dx + dy*dy + this.cfg.softening * this.cfg.softening;
        const invr3 = 1.0 / (Math.sqrt(r2) * r2); // 1/r^3
        return { x: this.gravity * starB.m * dx * invr3, y: this.gravity * starB.m * dy * invr3 };
    }
    // symplectic leapfrog for the two stars (stable for long runs)
    integrateStars(dt, starA, starB) {
        // compute initial accelerations
        const aA1 = this.accelOn(starA, starB);
        const aB1 = this.accelOn(starB, starA);

        // half kick
        starA.setVel(Point(
            starA.vel.x + 0.5 * aA1.x * dt,
            starA.vel.y + 0.5 * aA1.y * dt
        ));
        starB.setVel(Point(
            starB.vel.x + 0.5 * aB1.x * dt,
            starB.vel.y + 0.5 * aB1.y * dt
        ));

        // drift
        starA.setPos(Point(
            starA.pos.x + starA.vel.x * dt,
            starA.pos.y + starA.vel.y * dt
        ));
        starB.setPos(Point(
            starB.pos.x + starB.vel.x * dt,
            starB.pos.y + starB.vel.y * dt
        ));

        // compute accelerations at new positions
        const aA2 = this.accelOn(starA, starB);
        const aB2 = this.accelOn(starB, starA);

        // final half kick
        starA.setVel(Point(
            starA.vel.x + 0.5 * aA2.x * dt,
            starA.vel.y + 0.5 * aA2.y * dt
        ));
        starB.setVel(Point(
            starB.vel.x + 0.5 * aB2.x * dt,
            starB.vel.y + 0.5 * aB2.y * dt
        ));
    }
}

// star objects (center-of-mass at origin initially)
const starA = new Star({ m: params.M1, pos: {x:0,y:0}, vel: {x:0,y:0}, radius: 12 });
const starB = new Star({ m: params.M2, pos: {x:0,y:0}, vel: {x:0,y:0}, radius: 10 });

const sim = new Simulation(params);

function delta(a, b) {
    let dt = (a - b) / 1000;
    //if ( dt > 0.05 )  // cap big jumps
    //    dt = 0.05;
    return Math.min(0.05, dt);
}

// ---------- main loop ----------
let last = performance.now();
function animate(now){
    const dt = delta(now, last);
    last = now;
    // subdivide the time-step for stability/accuracy
    const sub = 4;
    const sdt = dt / sub;
    for ( let i=0; i < sub; i++ ) {
        sim.integrateStars(sdt, starA, starB);
    }
    ctx.fillStyle = "#000000";
    ctx.fillRect(0,0,canvas.width / DPR, canvas.height / DPR);
    starA.draw(ctx, 40);   // orange-ish
    starB.draw(ctx, 200);  // blue-ish

    requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

</script>
</body>
</html>
