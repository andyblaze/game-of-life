<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Supernova Demo - Buildup Tiny Star</title>
<style>
body { margin:0; background:black; overflow:hidden; }
canvas { display:block; }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
class Supernova {
    constructor(x, y, controls = {}) {
        this.x = x;
        this.y = y;
        this.start = performance.now();
        this.dead = false;

        // Buildup parameters
        this.buildupDuration = controls.buildupDuration || 15000; // 15s
        this.starBaseRadius = controls.starBaseRadius || 2;
        this.maxJitterPos = controls.maxJitterPos || 1.5;
        this.maxJitterRadius = controls.maxJitterRadius || 1;
        this.starPulseSpeed = controls.starPulseSpeed || 200; // slow color pulse
        this.starFlickerHue = controls.starFlickerHue || 15;

        // Explosion streaks
        this.streakCount = controls.streakCount || 90;
        this.streakMaxLen = controls.streakMaxLen || 260;
        this.streakDuration = controls.streakDuration || 3000;
        this.duration = controls.duration || 80000; // total life

        this.streaks = Array.from({length: this.streakCount}, () => ({
            angle: Math.random() * Math.PI * 2,
            len: 20 + Math.random() * (this.streakMaxLen - 20),
            width: 1 + Math.random() * 2
        }));

        // Nebula
        this.maxSize = controls.maxSize || 30;
        this.nebula = Array.from({length:5}, () => ({
            dx: (Math.random()-0.5)*this.maxSize,
            dy: (Math.random()-0.5)*this.maxSize,
            radius: 30 + Math.random()*50,
            color: `hsla(${180+Math.random()*120},80%,60%,0.25)`
        }));
    }

    draw(now, ctx){
        const t = now - this.start;
        if(t > this.duration){
            this.dead = true;
            return;
        }

        ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height);

        // Determine buildup phase
        const phaseTime = Math.min(1, t / this.buildupDuration);

        if(phaseTime < 1){
            // 1️⃣ Pre-flash tiny star with ramped color, size, position
            ctx.save();
            const pulse = Math.sin(t / this.starPulseSpeed * Math.PI*2);

            const radiusOffset = pulse * this.maxJitterRadius * phaseTime;
            const radius = Math.max(0.5, this.starBaseRadius + radiusOffset);

            const jitterX = (Math.random()-0.5) * this.maxJitterPos * phaseTime;
            const jitterY = (Math.random()-0.5) * this.maxJitterPos * phaseTime;

            const hueShift = (Math.random()-0.5) * this.starFlickerHue;
            const alpha = 0.4 + 0.6 * Math.abs(pulse) * phaseTime;

            ctx.fillStyle = `hsl(${60 + hueShift}, 100%, 80%, ${alpha})`;
            ctx.beginPath();
            ctx.ellipse(this.x + jitterX, this.y + jitterY, radius, radius, 0, 0, Math.PI*2);
            ctx.fill();
            ctx.restore();
        }

        // 2️⃣ Explosion streaks start immediately after buildup
        const streakLife = t - this.buildupDuration;
        if(streakLife > 0){
            ctx.save();
            ctx.translate(this.x, this.y);
            this.streaks.forEach(s=>{
                const lifeFrac = Math.min(1, streakLife / this.streakDuration);
                if(lifeFrac > 0){
                    const len = s.len * lifeFrac;
                    ctx.strokeStyle = `rgba(255,200,150,${1-lifeFrac})`;
                    ctx.lineWidth = s.width;
                    ctx.beginPath();
                    ctx.moveTo(0,0);
                    ctx.lineTo(Math.cos(s.angle)*len, Math.sin(s.angle)*len);
                    ctx.stroke();
                }
            });
            ctx.restore();
        }

        // 3️⃣ Nebula fade
        const nebLife = Math.min(1, (t-4000)/(this.duration-4000));
        const alpha = 0.9*(1-nebLife);
        this.nebula.forEach(n=>{
            const r = n.radius*(1+nebLife*2);
            const g = ctx.createRadialGradient(this.x+n.dx,this.y+n.dy,0,this.x+n.dx,this.y+n.dy,r);
            g.addColorStop(0, n.color.replace('0.25', `${0.9*alpha}`));
            g.addColorStop(1,'rgba(0,0,0,0)');
            ctx.fillStyle = g;
            ctx.beginPath();
            ctx.arc(this.x+n.dx,this.y+n.dy,r,0,Math.PI*2);
            ctx.fill();
        });
    }
}

// Canvas setup
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// Create supernova with buildup
const supernova = new Supernova(canvas.width/2, canvas.height/2, {
    buildupDuration: 5000,  // ms pre-flash buildup
    starBaseRadius: 2,
    maxJitterPos: 1.5,
    maxJitterRadius: 1,
    starPulseSpeed: 200,
    starFlickerHue: 15,
    maxSize: 30,
    streakCount: 90,
    streakMaxLen: 260,
    streakDuration: 3000,
    duration: 80000
});

function animate(now){
    supernova.draw(now, ctx);
    if(!supernova.dead) requestAnimationFrame(animate);
}
requestAnimationFrame(animate);
</script>
</body>
</html>
