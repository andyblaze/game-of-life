<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Particle Fountain (Cone, Smooth Start)</title>
  <style>
    body {
      margin: 0;
      background: black;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
const colors = [
    { h:16, s:"100%", l:"54%", a:1 },   
    { h:9, s:"100%", l:"64%", a:1 },    
    { h:39, s:"100%", l:"50%", a:1 },   
    { h:51, s:"100%", l:"50%", a:1 },   
    { h:60, s:"100%", l:"80%", a:1 },  
    { h:0, s:"100%", l:"50%", a:1 },    
    { h:0, s:"100%", l:"25%", a:1 },   
    { h:0, s:"0%", l:"27%", a:1 }      
];
const shapes = ["circle", "rect", "triangle", "line"];

function colorToStr(c) {
    return "hsla(" + Object.values(c).join(",") + ")";
}
function randomFrom(arr) {
    const index = Math.floor(Math.random() * arr.length);
    return arr[index];
}
function mt_rand(min = 0, max = 2147483647) {
    if (min > max) [min, max] = [max, min]; // swap if min > max
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
function clamp(value, min, max) {
    return Math.min(Math.max(value, min), max);
}
class Particle {
    constructor(x, y, config) {
        this.originalX = x;
        this.originalY = y;
        this.maxHeight = config.maxHeight;
        this.color = randomFrom(config.colors);
        this.shape = randomFrom(config.shapes);
        this.behavior = config.behavior;
        this.reset(true); // true = randomize start
    }
    reset(randomize=false) {
        this.x = this.originalX;
        this.y = this.originalY;
        this.color.a = 1;        
        this.behavior.reset(this, randomize);
    }
    update(dt) {
        this.behavior.update(this, dt);
    }
    draw(ctx) {
        this.behavior.draw(this, ctx);
    }
}

class Factory {
    static registry = {
        //FountainFx
        //RocketEffect
    };

    static create(className, config) {
        const Cls = this.registry[className];
        if (!Cls) throw new Error(`Unknown class: ${className}`);
        return new Cls(config);
    }
}

class Firework {
    constructor() {
        this.effects = [];
        this.spawnPoint = {};
    }
    updateAndDraw(dt, ctx) {
        for (const e of this.effects) {
            e.updateAndDraw(dt, ctx);
        }
    }
    spawnAt(position) {
        this.spawnPoint = position;
    }
}

class StarFountain extends Firework {
    constructor(position) {
        super();
        this.spawnPoint = position;
        this.effects.push(new FountainFx(position, {colors, shapes, maxHeight:400}));
    }
}

class FX {
    constructor() {
        this.spawnPoint = {};
        this.initialised = false;
    }
    doSetup() {}
    setup() {
        this.doSetup();
        this.initialised = true;
    }
}

class FxBehavior {
    update(p, dt) {}
    draw(ctx) {}
    reset(p, randomize) {}
}
class FountainBehavior extends FxBehavior {
    reset(p, randomize) {
        // Random cone spread (-x° to +x°)
        const angle = (Math.random() * 16 - 8) * (Math.PI / 180);
        const speed = 3 + Math.random() * 2;

        p.vx = Math.sin(angle) * speed;
        p.vy = -Math.cos(angle) * speed;
        p.size = 2 + Math.random() * 2;

        if (randomize) {
            // start partway through the fountain’s maxHeight
            const offset = Math.random() * p.maxHeight;
            p.y -= offset;
            p.color.a = 1 - (offset / p.maxHeight);
        }
    }
    update(p, dt) {
        p.x += p.vx;
        p.y += p.vy;

        const progress = (p.originalY - p.y) / p.maxHeight;
        p.color.a = Math.max(1 - progress, 0);

        if (p.y <= p.originalY - p.maxHeight) {
            p.reset();
        }
    }
    drawCircle(p, ctx) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size / 2, 0, 2*Math.PI);
        ctx.fill();
    }
    drawTriangle(p, ctx) {
        ctx.beginPath();
        ctx.moveTo(p.x, p.y - p.size/2);
        ctx.lineTo(p.x - p.size/2, p.y + p.size/2);
        ctx.lineTo(p.x + p.size/2, p.y + p.size/2);
        ctx.closePath();
        ctx.fill();
    }
    draw(p, ctx) {
    ctx.fillStyle = colorToStr(p.color);
        switch(p.shape) {
          case 'circle':
            this.drawCircle(p, ctx);
            break;

          case 'rect':
            ctx.fillRect(p.x, p.y, p.size, p.size);
            break;

          case 'triangle':
            this.drawTriangle(p, ctx);
            break;

          case 'line':
            ctx.fillRect(p.x, p.y, 1, p.size); // very short vertical line
            break;
        }
    }
}
class FountainFx extends FX {
    static defaults = {
        numParticles: 400,
        maxHeight:200,
        color: {h:0, s:"0%", l:"100%", a:1},
        shape:"circle",
        behavior: new FountainBehavior()
    };
    constructor(position, overrides={}) {
        super();
        this.spawnPoint = position;
        this.config = { ...FountainFx.defaults, ...overrides };
        this.particles = [];
    }
    doSetup() {
        for (let i = 0; i < this.config.numParticles; i++) {
            this.particles.push(new Particle(this.spawnPoint.x, this.spawnPoint.y, this.config));
        }
    }
    updateAndDraw(dt, ctx) {
        if ( false === this.initialised ) this.setup();
        for (const p of this.particles) {
            p.update(dt);
            p.draw(ctx);
        }
    }
}
class SprayBehavior {
  reset(p, randomize = false) {
    p.age = 0;
    p.lifetime = 5; // fallback if not in config
    p.alpha = 1;
    p.isAlive = true;

    // random spray velocity
    const angle = (Math.random() * Math.PI) / 2 - Math.PI / 4; // spread
    const speed = 4 * Math.random() + 4;
    p.vx = Math.sin(angle) * speed;
    p.vy = -Math.cos(angle) * speed;
    
    p.vx = 2.5;
    p.vy = -4.0;

    // trail history
    p.trail = [];
  }

  update(p, dt) {
    const deltaSeconds = dt / 1000;
    p.age += deltaSeconds;
    p.isAlive = (p.age <= p.lifetime || p.alpha == 0);
    //p.vy += 0.002;//400 * deltaSeconds; // gravity

    p.x += p.vx * deltaSeconds;
    p.y += p.vy * deltaSeconds; 

    p.alpha = clamp(1 - p.age / p.lifetime, 0, 1); console.log("deltaSeconds", Math.round(deltaSeconds), "lifetime: ", p.lifetime, "age: ", Math.round(p.age), "p.x: ", Math.round(p.x), "p.y: ", Math.round(p.y), "p.vx: ", Math.round(p.vx), "p.vy: ", Math.round(p.vy), "p.alpha: ", Math.round(p.alpha));

    // push to trail
    p.trail.push({ x: p.x, y: p.y, alpha: p.alpha });
    if (p.trail.length > 10) p.trail.shift();
  }

  draw(p, ctx) {
    // draw trail
    ctx.beginPath();
    for (let i = 0; i < p.trail.length; i++) {
      const t = p.trail[i];
      ctx.fillStyle = `rgba(255, 200, 50, ${t.alpha})`;
      ctx.fillRect(t.x, t.y, 2, 2);
    }

    // draw head particle
    ctx.fillStyle = `rgba(255, 150, 0, ${p.alpha})`;
    ctx.beginPath();
    ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
    ctx.fill();
  }
}
class SprayFx extends FX {
  static defaults = {
    numParticles: 1,
    maxHeight: 400,
    colors: [
      { h: 50, s: "100%", l: "50%", a: 1 }, // warm yellow/orange
      { h: 30, s: "100%", l: "50%", a: 1 }
    ],
    shape: "circle",
    behavior: new SprayBehavior(), 
    lifetime: 5
  };

  constructor(position, overrides = {}) {
    super();
    this.spawnPoint = position;
    this.config = { ...SprayFx.defaults, ...overrides };
    this.particles = [];
    this.initialised = false;
  }

  doSetup() {
    for (let i = 0; i < this.config.numParticles; i++) {
      this.particles.push(new Particle(this.spawnPoint.x, this.spawnPoint.y, this.config));
    }
  }
  updateAndDraw(dt, ctx) {
    if ( ! this.initialised ) this.setup();

    for (const p of this.particles) {
      p.update(dt);
      if ( ! p.isAlive ) {
        p.reset();
        this.initialised = false;
      }
      p.draw(ctx);
    }
  }
}

class SprayFountain extends Firework {
    constructor(position) {
        super();
        this.spawnPoint = position;
        this.effects.push(new SprayFx(position, {colors, shapes, maxHeight:400}));
    }
}
// Optional helper (include if you don't already have one)
function colorToStr(c) {
  // expects {h, s, l, a}
  return `hsla(${c.h}, ${c.s}, ${c.l}, ${c.a})`;
}


const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
resizeCanvas();

const fountain = new StarFountain({x:800, y:500, z:1});//{x:800, y:500, z:1}, {colors, shapes, maxHeight:400});
const spray = new SprayFountain({x:400, y:600, z:1})

let lastTime = performance.now();
function animate(timestamp) {
    if ( isNaN(timestamp) ) timestamp = 0;
    const dt = timestamp - lastTime; // milliseconds since last frame
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    fountain.updateAndDraw(timestamp, ctx);
    spray.updateAndDraw(timestamp, ctx);
    requestAnimationFrame(animate);
}

animate();

window.addEventListener('resize', resizeCanvas);

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
</script>
</body>
</html>
