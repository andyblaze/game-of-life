<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Jelly Bar Demo</title>
<style>
  body { margin: 0; background: #111; overflow: hidden; }
  canvas { display: block; }
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<script>
const perlin = {
  noise: (x, y, z = 0) => {
    return Math.sin(x * 2 + y * 2 + z) * 0.5 + 0.5; // simple demo
  }
};

function curlNoise(x, y, t, scale = 1, eps = 1e-3) {
  // dummy curl noise example, replace with your real function
  const n1 = perlin.noise(x + eps, y, t);
  const n2 = perlin.noise(x - eps, y, t);
  const n3 = perlin.noise(x, y + eps, t);
  const n4 = perlin.noise(x, y - eps, t);
  const curlX = (n3 - n4) / (2 * eps);
  const curlY = -(n1 - n2) / (2 * eps);
  return { x: curlX * scale, y: curlY * scale };
}

class DeltaReport {
    static lastTime = performance.now();
    static frameCount = 0;
    static sum = 0;
    static min = 60;
    static max = 0;
    static elapsedSeconds = 0;
    static report = document.getElementById("fps-report");
    
    static log(timestamp) {
        this.frameCount++;
        const delta = (timestamp - this.lastTime) / 16.67;
        this.sum += delta;
        this.lastTime = timestamp;
        if ( this.frameCount === 120 ) { // every 2 seconds
            this.elapsedSeconds += 2;
            const minutes = Math.floor(this.elapsedSeconds / 60);
            const fps = parseInt(60 / (this.sum / this.frameCount));
            if ( fps < this.min ) this.min = fps; 
            if ( fps > this.max ) this.max = fps; 
            console.log("time", `${minutes}:${this.elapsedSeconds % 60}`, " fps=", fps, " min=", this.min, " max=", this.max);
            //this.report.innerText = fps + " " + this.min + " " + this.max;
            this.frameCount = 0;
            this.sum = 0;
        }
    }
}

// ===== Setup =====
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// Animation variables
let time = 0;

// Bar parameters
const barWidth = 120;
const barHeight = 600;
const baseX = canvas.width / 2 - barWidth / 2;
const baseY = 760;//canvas.height - 50; // bottom anchor
const segments = 60; // number of points along sides

function drawBar(ts) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Top corners with noise
    const topLeft = {
        x: baseX + perlin.noise(time*0.1, 0)*20,
        y: baseY - barHeight + perlin.noise(time*0.2, 0)*20
    };
    const topRight = {
        x: baseX + barWidth + perlin.noise(time*0.1, 1)*20,
        y: baseY - barHeight + perlin.noise(time*0.2, 1)*20
    };

    // Bottom corners (anchored)
    const bottomLeft = { x: baseX, y: baseY };
    const bottomRight = { x: baseX + barWidth, y: baseY };

    ctx.beginPath();

    // Left side interpolation
    for (let i = 0; i <= segments; i++) {
        const t = i / segments;
        let x = bottomLeft.x + (topLeft.x - bottomLeft.x) * t;
        let y = bottomLeft.y + (topLeft.y - bottomLeft.y) * t;
        // apply some small wobble along side
        const noise = perlin.noise(x*0.05, y*0.05, time*0.5);
        const curl = curlNoise(x * 2, y * 1, time);
        x += curl.x * 5;
        y += curl.y * 5;

        x += noise * 4;
        //y += noise * 5;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    }

    // Top edge
    for (let i = 0; i <= segments; i++) {
        const t = i / segments;
        let x = topLeft.x + (topRight.x - topLeft.x) * t;
        let y = topLeft.y + (topRight.y - topLeft.y) * t;
        const noise = perlin.noise(x*0.05, y*0.05, time*0.7);
        x += noise * 5;
        y += noise * 5;
        ctx.lineTo(x, y);
    }

    // Right side interpolation down to bottomRight
    for (let i = segments; i >= 0; i--) {
        const t = i / segments;
        let x = bottomRight.x + (topRight.x - bottomRight.x) * t;
        let y = bottomRight.y + (topRight.y - bottomRight.y) * t;
        const noise = perlin.noise(x*0.05, y*0.05, time*0.5);
        const curl = curlNoise(x * 2, y * 1, time);
        x += curl.x * 5;
        y += curl.y * 5;

        x += noise * 4;
        ctx.lineTo(x, y);
    }

    ctx.closePath();

    // Fill with gradient
    const grad = ctx.createLinearGradient(baseX, baseY, baseX, baseY - barHeight);
    grad.addColorStop(0, '#ff5555');
    grad.addColorStop(0.5, '#ffaa00');
    grad.addColorStop(1, '#ffff55');
    ctx.fillStyle = grad;
    ctx.fill();

    time += 0.01;
    DeltaReport.log(ts);
    requestAnimationFrame(drawBar);
}

drawBar();
</script>
</body>
</html>
