<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Particles + Curl Noise</title>
<style>
  html,body { height:100%; margin:0; background:#000 }

  #ui {
    position: fixed; left: 12px; top: 12px; color: #eee; font-family: system-ui, sans-serif;
    background: rgba(0,0,0,0.35); padding:8px 10px; border-radius:8px; font-size:13px;
  }
  label { display:inline-flex; gap:6px; align-items:center; }
  input[type=range] { width:140px; vertical-align:middle; }
  #c {
  display:block; width:100vw; height:100vh;
}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="ui">
  <div><label>Particles <span id="pc">1000</span><input id="pRange" type="range" min="200" max="6000" value="250"></label></div>
  <div style="margin-top:6px"><label>Noise scale <span id="ns">0.002</span><input id="sRange" type="range" min="0.0005" max="0.01" step="0.0001" value="0.002"></label></div>
  <div style="margin-top:6px"><label>Speed <span id="sp">1.0</span><input id="vRange" type="range" min="0.1" max="6" step="0.1" value="0.1"></label></div>
  <div style="margin-top:6px"><label>Trail (alpha) <span id="al">0</span><input id="aRange" type="range" min="0" max="1" step="0.1" value="0.5"></label></div>
  <div style="margin-top:8px;font-size:12px;opacity:0.85">Click to respawn particles • Drag to push</div>
</div>

<script>
class DeltaReport {
    static lastTime = performance.now();
    static frameCount = 0;
    static sum = 0;
    static min = 60;
    static max = 0;
    static elapsedSeconds = 0;
    static report = document.getElementById("fps-report");
    
    static log(timestamp) {
        this.frameCount++;
        const delta = (timestamp - this.lastTime) / 16.67;
        this.sum += delta;
        this.lastTime = timestamp;
        if ( this.frameCount === 120 ) { // every 2 seconds
            this.elapsedSeconds += 2;
            const minutes = Math.floor(this.elapsedSeconds / 60);
            const fps = parseInt(60 / (this.sum / this.frameCount));
            if ( fps < this.min ) this.min = fps; 
            if ( fps > this.max ) this.max = fps; 
            console.log("time", `${minutes}:${this.elapsedSeconds % 60}`, " fps=", fps, " min=", this.min, " max=", this.max);
            //this.report.innerText = fps + " " + this.min + " " + this.max;
            this.frameCount = 0;
            this.sum = 0;
        }
    }
}
/* -------------------------
   Simple Perlin noise (improved)
   ------------------------- */
class Perlin {
  constructor() {
    this.p = new Uint8Array(512);
    const perm = new Uint8Array([
      151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
      190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
      77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,
      189,28,42,223,183,170,213,119,248,152, 2,44,154,163,70,221,153,101,155,167, 43,172,9,129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127, 4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180
    ]);
    for (let i = 0; i < 512; ++i) this.p[i] = perm[i & 255];
  }

  fade(t){ return t*t*t*(t*(t*6 -15) +10); }
  lerp(a,b,t){ return a + t*(b-a); }
  grad(hash, x, y, z=0) {
    const h = hash & 15;
    const u = h<8 ? x : y;
    const v = h<4 ? y : (h===12||h===14 ? x : z);
    return ((h&1)? -u : u) + ((h&2)? -v : v);
  }

  // 3D Perlin (we use third dim as time)
  noise(x, y, z=0) {
    const X = Math.floor(x) & 255;
    const Y = Math.floor(y) & 255;
    const Z = Math.floor(z) & 255;
    x -= Math.floor(x); y -= Math.floor(y); z -= Math.floor(z);
    const u = this.fade(x), v = this.fade(y), w = this.fade(z);
    const p = this.p;

    const A  = p[X  ]+Y, AA = p[A]+Z, AB = p[A+1]+Z;
    const B  = p[X+1]+Y, BA = p[B]+Z, BB = p[B+1]+Z;

    return this.lerp(
      this.lerp(
        this.lerp(this.grad(p[AA], x  , y  , z   ), this.grad(p[BA], x-1, y  , z   ), u),
        this.lerp(this.grad(p[AB], x  , y-1, z   ), this.grad(p[BB], x-1, y-1, z   ), u),
        v
      ),
      this.lerp(
        this.lerp(this.grad(p[AA+1], x  , y  , z-1 ), this.grad(p[BA+1], x-1, y  , z-1 ), u),
        this.lerp(this.grad(p[AB+1], x  , y-1, z-1 ), this.grad(p[BB+1], x-1, y-1, z-1 ), u),
        v
      ),
      w
    );
  }
}

/* -------------------------
   Curl noise helper (2D)
   Use scalar noise n(x,y,t). Curl = (∂n/∂y, -∂n/∂x)  (gives divergence-free field)
   We'll get derivatives via central differences.
   ------------------------- */

const perlin = new Perlin();

function curlNoise(x, y, t, scale, eps = 1e-3) {
  // sample positions scaled
  const sx = x * scale;
  const sy = y * scale;
  const dt = t * 0.0005;

  // finite differences for partial derivatives of scalar field n(x,y,t)
  const n_x1 = perlin.noise(sx + eps, sy, dt);
  const n_x2 = perlin.noise(sx - eps, sy, dt);
  const n_y1 = perlin.noise(sx, sy + eps, dt);
  const n_y2 = perlin.noise(sx, sy - eps, dt);

  const dx = (n_x1 - n_x2) / (2 * eps);
  const dy = (n_y1 - n_y2) / (2 * eps);

  // curl of gradient-like scalar -> divergence-free 2D vector
  // vector = (d/dy n, -d/dx n)
  return { x: dy, y: -dx };
}

function mt_rand(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
function clamp(value, min, max) {
    return Math.min(Math.max(value, min), max);
}

/* -------------------------
   Particles
   ------------------------- */

const onscreen = document.getElementById('c');
const onCtx = onscreen.getContext('2d', { alpha: true });
let W = onscreen.width = window.innerWidth;
let H = onscreen.height = window.innerHeight;
const offscreen = document.createElement("canvas");
const offCtx = offscreen.getContext("2d");
offscreen.width = W;
offscreen.height = H;

window.addEventListener('resize', () => { 
    W = onscreen.width = window.innerWidth; 
    H = onscreen.height = window.innerHeight; 
    offscreen.width = W;
    offscreen.height = H;
});

let PARTICLE_COUNT = 50;
const maxCountEl = document.getElementById('pc');
const pRange = document.getElementById('pRange');
pRange.addEventListener('input', (e) => {
  PARTICLE_COUNT = +e.target.value;
  maxCountEl.textContent = PARTICLE_COUNT;
  syncParticles();
});

const sRange = document.getElementById('sRange');
const nsEl = document.getElementById('ns');
sRange.addEventListener('input', () => nsEl.textContent = parseFloat(sRange.value).toFixed(4));

const vRange = document.getElementById('vRange');
const spEl = document.getElementById('sp');
vRange.addEventListener('input', () => spEl.textContent = parseFloat(vRange.value).toFixed(1));

const aRange = document.getElementById('aRange');
const alEl = document.getElementById('al');
aRange.addEventListener('input', () => alEl.textContent = parseFloat(aRange.value).toFixed(2));


function randomParticle() {
    return {
        x: Math.random() * W,
        y: Math.random() * H,
        vx: 0,
        vy: 0,
        age: 0,
        hue: Math.random() * 360,
        r: 0.6 + Math.random() * 1.8
    };
}
class VirtualMouse {
    constructor() {
        this.xCoord = 0;
        this.yCoord = 0;
        this.x = 0;
        this.y = 0;
        this.down = false;
        this.dragSpeed = 0;
        this.lifetime = 0;
        this.age = 0;
    }
    mouseDown() {
        this.xCoord = W - mt_rand(10, 200);
        this.yCoord = mt_rand(100, H - 100);
        this.x = this.xCoord;
        this.y = this.yCoord;
        this.lifetime = mt_rand(10, 20);
        this.dragSpeedX = mt_rand(2, 4);
        this.dragSpeedY = Math.random() - 0.5;
        this.down = true;
    }
    mouseUp() {
        this.age = 0;
        this.down = false;
    }
    offScreen() {
        return this.x < 1 || this.x > W || this.y < 1 || this.y > H;
    }
    mouseDrag() {
        this.age += 0.02;
        this.x -= this.dragSpeedX;
        this.y += this.dragSpeedY;
        if ( this.age > this.lifetime || this.offScreen() )
            this.mouseUp();
    } 
    trigger() {
        if ( this.down === true ) return true;
        if ( this.down === false && Math.random() < 0.001 ) {
            this.mouseDown();
            return true;
        }
        return false;
    }
}
const virtualMouse = new VirtualMouse();
const scale = parseFloat(sRange.value); // noise scale
const speed = parseFloat(vRange.value) * 0.6; // global speed

class ParticleManager {
    constructor(count, scale, speed, flowRate) {
        this.scale = scale;
        this.speed = speed;
        this.flowRate = flowRate; // speed from left to right
        this.items = [];
        for ( let i = 0; i < count; i++ ) 
            this.add(randomParticle());
    }
    sync(count) {
        if ( this.items.length < count ) {
            const toAdd = count - this.items.length;
            for ( let i = 0; i < toAdd; i++ ) 
                this.items.push(randomParticle());
        } else {
            this.items.length = count;
        }
    }
    add(p) {
        this.items.push(p);
    }
    applyNoise(p, dt, now) {
        const c = curlNoise(p.x, p.y, now, this.scale, 1e-3);
        // small normalization so vectors are a bit smoother
        const mag = Math.hypot(c.x, c.y) + 1e-6;
        const fx = (c.x / mag) * this.speed;
        const fy = (c.y / mag) * this.speed;

        // verlet-ish integration (simple)
        p.vx += fx * dt * 0.3;
        p.vy += fy * dt * 0.3;
    }
    update(dt, now) {
        for ( const p of this.items ) {
            this.applyNoise(p, dt, now);
            // particles flow
            p.vx += this.flowRate;
            // damping
            p.vx *= 0.985;
            p.vy *= 0.985;

            // add mouse influence if dragging
            if ( virtualMouse.down ) {
                const mx = virtualMouse.x, my = virtualMouse.y;
                const dx = p.x - mx, dy = p.y - my;
                const dist2 = dx*dx + dy*dy;
                if ( dist2 < 20000 ) {
                    p.vx += (dx / (Math.sqrt(dist2)+20)) * 0.08;
                    p.vy += (dy / (Math.sqrt(dist2)+20)) * 0.08;
                }
            }

            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.age += dt;

            this.wrapAround(p);
        }
    }
    wrapAround(p) {
        if (p.x < -10) p.x = W + 10;
        if (p.x > W + 10) p.x = -10;
        if (p.y < -10) p.y = H + 10;
        if (p.y > H + 10) p.y = -10;
    }
    draw(ctx) {
        ctx.globalCompositeOperation = "lighter"; // glow-ish additive blending
        for ( const p of this.items ) {
            const alpha = 0.6;
            const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r * 6);
            grad.addColorStop(0, `hsla(${p.hue}, 90%, 60%, ${alpha})`);
            grad.addColorStop(0.4, `hsla(${(p.hue+40)%360}, 90%, 55%, ${alpha*0.45})`);
            grad.addColorStop(1, `hsla(${(p.hue+80)%360}, 80%, 20%, 0)`);
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.r*6, 0, Math.PI*2);
            ctx.fill();
        }
        ctx.globalCompositeOperation = "source-over";
    }
}

//const particleManager = new ParticleManager(PARTICLE_COUNT, scale, speed);

class FullScreenOverlay {
    constructor({ color = "255, 0, 0, 0.01", min = 0.05, max = 0.2, speed = 0.025, scale = 0.25 } = {}) {
        this.color = color;
        this.min = min;
        this.max = max;
        this.speed = speed;
        this.scale = scale;

        this._elapsed = 0;
        this._opacity = (this.max - this.min) / 2;

        // --- pre-render setup ---
        this.buffer = document.createElement("canvas");
        this.buffer.width = window.innerWidth * this.scale;
        this.buffer.height = window.innerHeight * this.scale;
        this.bufCtx = this.buffer.getContext("2d");

        // fill buffer once (solid color, full alpha)
        this.bufCtx.fillStyle = `rgba(${this.color})`;
        this.bufCtx.fillRect(0, 0, this.buffer.width, this.buffer.height);
    }

    update() {
        this._elapsed = (this._elapsed + this.speed) % (Math.PI * 2);
        const amplitude = (this.max - this.min) / 2;
        const midpoint = (this.max + this.min) / 2;
        this._opacity = midpoint + amplitude * Math.sin(this._elapsed);
    }

    draw(ctx, width, height) {
        this.update();
        //ctx.save();
        //ctx.globalAlpha = this._opacity;
        ctx.drawImage(this.buffer, 0, 0, width, height); // scaled blit
        //ctx.restore();
    }
}

/* -------------------------
   Animation
   ------------------------- */
const pebbles = new Image();
pebbles.src = "bg.jpg";

class Lamp {
    constructor(w, h, perlin, color) {
        this.w = w;
        this.h = h;
        this.perlin = perlin;
        this.color = color;
        // base position spreads lamps across the canvas
        this.baseX = Math.random() * w;
        this.baseY = Math.random() * h;        
        // Perlin offsets
        this.nx = Math.random() * 1000;
        this.ny = Math.random() * 1000;
        // drift range in pixels
        this.driftX = 550 + Math.random() * 50;
        this.driftY = 330 + Math.random() * 30;        
        // current position
        this.x = this.baseX;
        this.y = this.baseY;
        // visual properties
        this.alpha = 0.3 + Math.random() * 0.2;
        this.radius = 64 + Math.pow(Math.random(), 2.2) * (512 - 128);
        this.speed = 0.002 + Math.random() * 0.0003;
    }
    move(dt) {
        // increment Perlin coordinates
        this.nx += this.speed * dt;
        this.ny += this.speed * dt;

        // compute smooth drift around base position
        this.x = this.baseX + (this.perlin.noise(this.nx, 0) * this.driftX);
        this.y = this.baseY + (this.perlin.noise(0, this.ny) * this.driftY);

        // optional alpha flicker
        this.alpha = 0.3 + (this.perlin.noise(this.nx + 5000, this.ny + 5000) * 0.1);
    }
}

class Lighting {
    constructor(w, h, perlin, numLamps = 20) {
        this.w = w;
        this.h = h;
        this.perlin = perlin;

        // create reusable radial blobs
        this.blobs = this.makeBlobs(6); // 6 variations

        // initialize lamps
        this.lamps = [];
        for (let i = 0; i < numLamps; i++) {
            const color = this.blobs[mt_rand(0, this.blobs.length - 1)];
            this.lamps.push(new Lamp(w, h, perlin, color));
        }
    }
  makeBlobs(count) {
    const blobs = [];
    for (let i = 0; i < count; i++) {
      const sz = 96 + Math.random() * 160;
      const hue = 45 + Math.random() * 20;          // golden/yellow tone
      const sat = 70 + Math.random() * 20;
      const light = 60 + Math.random() * 10;
      const alpha = 0.35 + Math.random() * 0.2;

      const blob = document.createElement('canvas');
      blob.width = blob.height = sz;
      const bctx = blob.getContext('2d');
      const r = sz / 2;
      const g = bctx.createRadialGradient(r, r, 0, r, r, r);
      g.addColorStop(0, `hsla(${hue},${sat}%,${light}%,${alpha})`);
      g.addColorStop(0.4, `hsla(${hue},${sat}%,${light - 20}%,${alpha * 0.2})`);
      g.addColorStop(1, `hsla(${hue},${sat}%,${light - 40}%,0)`);

      bctx.fillStyle = g;
      bctx.fillRect(0, 0, sz, sz);
      blobs.push(blob);
    }
    return blobs;
  }
    update(dt) {
        // move all lamps
        for (let lamp of this.lamps) {
            lamp.move(dt);
            // optional subtle alpha flicker
            lamp.alpha = 0.3 + (this.perlin.noise(lamp.nx + 5000, lamp.ny + 5000) * 0.1);
        }
    }
    draw(ctx) {
        ctx.save();
        ctx.globalCompositeOperation = 'screen';  // additive blending
        //ctx.filter = 'blur(2px)';                 // soft glow
        for (let lamp of this.lamps) {
            const size = lamp.radius || this.blob.width;
            ctx.globalAlpha = lamp.alpha;
            ctx.drawImage(
                lamp.color,
                lamp.x - size / 2,
                lamp.y - size / 2,
                size,
                size
            );
        }
        ctx.restore();
    }

    // convenience: update and draw in one call
    step(dt, ctx) {
        this.update(dt);
        this.draw(ctx);
    }
}

const layerConfig = [
  { count: 73, scale: 0.002, speed: 0.06, hueShift: 0,   alpha: 0.7, sizeMult: 0.7, flowRate:0.01 }, // surface
  { count: 73, scale: 0.001, speed: 0.03, hueShift: 15,  alpha: 0.5, sizeMult: 1.0, flowRate:0.005 }, // mid
  { count: 73, scale: 0.0006, speed: 0.01, hueShift: 40, alpha: 0.35, sizeMult: 1.3, flowRate:0.003 } // deep
];

class ParticleSystem {
    constructor(configs) {
        // Each config describes a layer
        // e.g. { count, scale, speed, hueShift, alpha, sizeMult }
        this.layers = configs.map(cfg => {
            const layer = new ParticleManager(cfg.count, cfg.scale, cfg.speed, cfg.flowRate);
            layer.hueShift = cfg.hueShift ?? 0;
            layer.alpha = cfg.alpha ?? 0.6;
            layer.sizeMult = cfg.sizeMult ?? 1.0;
            return layer;
        });
    }

    update(dt, now) {
        for (const layer of this.layers) {
            layer.update(dt, now);
        }
    }

    draw(ctx) {
        for (const layer of this.layers) {
            ctx.globalCompositeOperation = "lighter";
            for (const p of layer.items) {
                const alpha = layer.alpha;
                const hue = (p.hue + (layer.hueShift || 0)) % 360;
                const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r * 6 * (layer.sizeMult || 1));
                grad.addColorStop(0, `hsla(${hue}, 90%, 60%, ${alpha})`);
                grad.addColorStop(0.4, `hsla(${(hue+40)%360}, 90%, 55%, ${alpha*0.45})`);
                grad.addColorStop(1, `hsla(${(hue+80)%360}, 80%, 20%, 0)`);
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.r * 6 * (layer.sizeMult || 1), 0, Math.PI * 2);
                ctx.fill();
            }
        }
        ctx.globalCompositeOperation = "source-over";
    }
}
const particleSystem = new ParticleSystem(layerConfig);

const lighting = new Lighting(W, H, perlin, 15);
//const overlay = new FullScreenOverlay();

function blit() {
    onCtx.clearRect(0, 0, onscreen.width, onscreen.height);
    onCtx.drawImage(offscreen, 0, 0);  
}
    //onCtx.drawImage(pebbles, 0, 0, W, H);

let last = performance.now();
function step(now) {
    if ( virtualMouse.trigger() )
        virtualMouse.mouseDrag();

    const dtMs = now - last;
    last = now;
    const dt = Math.min(dtMs / 16.6667, 4); // normalized, cap to avoid jumps

    onCtx.drawImage(pebbles, 0, 0, W, H);
    
    lighting.step(dt, onCtx);
    //overlay.draw(offCtx, W, H);

    onCtx.fillStyle = "rgba(0,0,0,0.1)";//${parseFloat(aRange.value)})`; // trail alpha from UI
    onCtx.fillRect(0,0,W,H);

    // update particles
particleSystem.update(dt, now);
particleSystem.draw(onCtx);
    //particleManager.update(dt, now, scale, speed);
    //particleManager.draw(onCtx);
    //particleManager.sync(PARTICLE_COUNT);
    //blit();

    DeltaReport.log(now);

    requestAnimationFrame(step);
}

// kick off
//ctx.fillStyle = 'black';
//ctx.fillRect(0,0,W,H);
requestAnimationFrame(step);
</script>
</body>
</html>
