<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<title>Binary stars — basic</title>
<style>
  html,body { height:100%; margin:0; background:#000; }
  canvas { display:block; width:100vw; height:100vh; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
/*
  Minimal binary-star orbit demo (no UI).
  - Two masses M1 and M2
  - Separation (pixels) and desired orbital period (seconds)
  - G is computed so the circular-orbit period ~ desiredPeriod
  - Leapfrog integrator (symplectic) used to advance the two-body system
  Tweak params below to experiment.
*/

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

function resize() {
    const DPR = window.devicePixelRatio || 1;
    canvas.width = window.innerWidth * DPR;
    canvas.height = window.innerHeight * DPR;
    canvas.style.width = window.innerWidth + "px";
    canvas.style.height = window.innerHeight + "px";
    // draw in CSS pixels (transform to account for DPR)
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
}
window.addEventListener('resize', resize);
resize();

// ---------- Simulation parameters (edit these) ----------
const params = {
    M1: 1.0,             // mass of star A (donor)
    M2: 2.4,             // mass of star B (accretor)
    separation: 260,     // separation between star centers in pixels
    desiredPeriod: 28.0,  // desired orbital period in seconds (used to pick G)
    softening: 1.0,      // gravitational softening in pixels (prevents singularity)
    visualScale: 4.0,     // world -> screen scale (pixels per world unit)
    eccentricity: 0.4,  // 0 = circle, 0.4 = noticeable ellipse, <1
    canvasW: canvas.width,
    canvasH: canvas.height,
    DPR: window.devicePixelRatio || 1
};
// -------------------------------------------------------

function Point(a, b) {
    return { "x": a, "y": b };
}

class Star {
    constructor(config, extra) {
        this.cfg = { ...config, ...extra };
        this.cfg.canvasSz = Point(config.canvasW, config.canvasH);
        this.cfg.scale = config.visualScale;
        this.cfg.dpr = config.DPR;
        this.hue = this.cfg.hue;
        this.mass = config.mass;
        this.pos = {x:0,y:0};
        this.vel = {x:0,y:0};
        this.radius = config.radius;
    } 
    worldToScreen(p){
        return Point(
            this.cfg.canvasSz.x / this.cfg.dpr * 0.5 + p.x * this.cfg.scale,
            this.cfg.canvasSz.y / this.cfg.dpr * 0.5 + p.y * this.cfg.scale
        );
    }
    draw(ctx) {
        const screen = this.worldToScreen(this.pos);
        const r = Math.max(3, this.radius * this.cfg.scale);
        // small bright core
        ctx.fillStyle = `hsla(${this.hue},100%,70%,1)`;
        ctx.beginPath();
        ctx.arc(screen.x, screen.y, r * 0.8, 0, Math.PI * 2);
        ctx.fill();
    }
    setPosition(x, y) {
        this.pos = Point(x, y);
    }
    setVelocity(vx, vy) {
        this.vel = Point(vx, vy);
    }
}

class Simulation {
    constructor(config) {
        this.cfg = config;
        this.gravity = 0;
        //this.initBinary(config)
    }
    // compute G so that circular-orbit period equals desiredPeriod:
    // omega = 2*pi/T ; for circular orbit: omega^2 = G*(M1+M2)/a^3
    computeG(M1, M2, dist, T) {
        const omega = 2 * Math.PI / T;
        this.gravity = Math.pow(dist, 3) * omega * omega / (M1 + M2);
    }
    initBinary(starA, starB) {
        const cfg = this.cfg;
        this.computeG(cfg.M1, cfg.M2, cfg.separation, cfg.desiredPeriod);
        const M1 = cfg.M1, M2 = this.cfg.M2;
        const dist = cfg.separation;

        // center-of-mass at origin
        starA.setPosition(- (M2 / (M1 + M2)) * dist, 0);
        starB.setPosition(+ (M1 / (M1 + M2)) * dist, 0);

        // circular orbital velocity at this distance
        const vCirc = Math.sqrt(this.gravity * (M1 + M2) / dist);

        // scale by eccentricity: treat initial position as apocenter
        const factor = Math.sqrt((1 - cfg.eccentricity) / (1 + cfg.eccentricity));
        const v = vCirc * factor;

        // assign velocities perpendicular to radius vector
        starA.setVelocity(0, -v * (M2 / (M1 + M2)));
        starB.setVelocity(0, +v * (M1 / (M1 + M2)));

        starA.mass = M1; 
        starB.mass = M2;
        starA.radius = Math.max(6, 12 * Math.cbrt(M1));
        starB.radius = Math.max(5, 10 * Math.cbrt(M2));
    }
    // compute acceleration on 2 bodies (softened)
    accelOn(starA, starB) {
        const dx = starB.pos.x - starA.pos.x;
        const dy = starB.pos.y - starA.pos.y;
        const r2 = dx*dx + dy*dy + this.cfg.softening * this.cfg.softening;
        const invr3 = 1.0 / (Math.sqrt(r2) * r2); // 1/r^3
        return { x: this.gravity * starB.mass * dx * invr3, y: this.gravity * starB.mass * dy * invr3 };
    }
    // symplectic leapfrog for the two stars (stable for long runs)
    integrateStars(dt, starA, starB) {
        // compute initial accelerations
        const aA1 = this.accelOn(starA, starB);
        const aB1 = this.accelOn(starB, starA);

        // half kick
        starA.setVelocity(
            starA.vel.x + 0.5 * aA1.x * dt,
            starA.vel.y + 0.5 * aA1.y * dt
        );
        starB.setVelocity(
            starB.vel.x + 0.5 * aB1.x * dt,
            starB.vel.y + 0.5 * aB1.y * dt
        );

        // drift
        starA.setPosition(
            starA.pos.x + starA.vel.x * dt,
            starA.pos.y + starA.vel.y * dt
        );
        starB.setPosition(
            starB.pos.x + starB.vel.x * dt,
            starB.pos.y + starB.vel.y * dt
        );

        // compute accelerations at new positions
        const aA2 = this.accelOn(starA, starB);
        const aB2 = this.accelOn(starB, starA);

        // final half kick
        starA.setVelocity(
            starA.vel.x + 0.5 * aA2.x * dt,
            starA.vel.y + 0.5 * aA2.y * dt
        );
        starB.setVelocity(
            starB.vel.x + 0.5 * aB2.x * dt,
            starB.vel.y + 0.5 * aB2.y * dt
        );
    }
    draw(ctx) {
        ctx.fillStyle = "#000000";
        ctx.fillRect(0, 0, this.cfg.canvasW / this.cfg.DPR, this.cfg.canvasH / this.cfg.DPR);    
    }
}

class Model {
    constructor(params) {
        this.starA = new Star(params, { mass: params.M1, radius: 12, hue: 40 });
        this.starB = new Star(params, {mass: params.M2,  radius: 10, hue: 200 });
        this.sim = new Simulation(params);
        this.sim.initBinary(this.starA, this.starB);
    }
    update(sdt) {
        this.sim.integrateStars(sdt, this.starA, this.starB);
        return [this.sim, this.starA, this.starB];
    }
}

class View {
    static draw(ctx, items) {
        for ( const i of items ) {
            i.draw(ctx);
        }
    }
}

const model = new Model(params);

class Controller {
    constructor(params) {
        this.last = performance.now();
        this.cfg = params;
    }
    delta(a, b) {
        const dt = (a - b) / 1000; // ms → s
        return Math.max(0, Math.min(0.05, dt));
    }
    animate(now) {
        let items;
        const dt = this.delta(now, this.last);
        this.last = now;
        // subdivide the time-step for stability/accuracy
        const sub = 4;
        const sdt = dt / sub;
        for ( let i = 0; i < sub; i++ ) {
            items = model.update(sdt);
        }
        View.draw(ctx, items);
        requestAnimationFrame(this.animate.bind(this));
    }
}

const controller = new Controller(params);
controller.animate(performance.now());

</script>
</body>
</html>
