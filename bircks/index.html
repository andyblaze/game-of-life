<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Sage Brick Wall â€” Balanced Perspective Pop-Out</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body{height:100%;margin:0;background:#9aaea0;}
    canvas{display:block;width:100%;height:100vh}
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <script>
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d', { alpha: false });

    let DPR = window.devicePixelRatio || 1;
    function resize() {
      DPR = window.devicePixelRatio || 1;
      canvas.width = Math.floor(window.innerWidth * DPR);
      canvas.height = Math.floor(window.innerHeight * DPR);
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
      grid.resize();
    }
    window.addEventListener('resize', resize);

    const BG_COLOR = '#9aaea0';
    const BRICK_ROWS = 10;
    const BRICK_COLS = 18;
    const POP_DURATION = 2000; // ms for pop effect

    const easeOutCubic = t => 1 - Math.pow(1 - t, 3);

    class Brick {
      constructor(i,j,w,h,x,y){
        this.i = i; this.j = j;
        this.w = w; this.h = h;
        this.x = x; this.y = y;
        this.pop = 0;
        this.popDir = 0;
        this.popDuration = POP_DURATION;
        this.age = 0;
      }

      trigger(duration){
        this.popDuration = duration || POP_DURATION;
        this.popDir = 1;
        this.age = 0;
      }

      update(dt){
        if(this.popDir === 0) return;
        this.age += dt;
        let t = Math.min(1, this.age / this.popDuration);
        if(this.popDir === 1){
          this.pop = easeOutCubic(t);
          if(t >= 1){ this.popDir = -1; this.age = 0; }
        } else if(this.popDir === -1){
          this.pop = 1 - easeOutCubic(t);
          if(t >= 1){ this.popDir = 0; this.pop = 0; }
        }
      }

      draw(ctx, DPR){
        const px = this.x * DPR, py = this.y * DPR, pw = this.w * DPR, ph = this.h * DPR;
        const edgeWidthBase = 4 * DPR;

        ctx.save();
        ctx.fillStyle = BG_COLOR;
        ctx.fillRect(px, py, pw, ph);

        if(this.pop > 0){
          // center offsets normalized -1..1
          const cx = px + pw/2, cy = py + ph/2;
          const dx = (cx - canvas.width/2)/(canvas.width/2);
          const dy = (cy - canvas.height/2)/(canvas.height/2);

          // base highlight/shadow, ensures balance
          const baseHighlight = 0.2;
          const baseShadow = 0.2;

          // directional contribution (-1..1) scaled to 0..0.4
          const dirTop = Math.max(0, -dy) * 0.4;
          const dirBottom = Math.max(0, dy) * 0.4;
          const dirLeft = Math.max(0, -dx) * 0.4;
          const dirRight = Math.max(0, dx) * 0.4;

            const topAlpha = baseHighlight + this.pop * Math.max(0, dy);      // brick below center -> more top highlight
            const bottomAlpha = baseShadow + this.pop * Math.max(0, -dy);     // brick above center -> more bottom shadow
            const leftAlpha = baseHighlight + this.pop * Math.max(0, dx);     // brick right of center -> more left highlight
            const rightAlpha = baseShadow + this.pop * Math.max(0, -dx);      // brick left of center -> more right shadow


          const edgeWidth = edgeWidthBase * this.pop;

          // draw edges with balanced highlight/shadow
          ctx.fillStyle = `rgba(255,255,255,${topAlpha})`; ctx.fillRect(px, py, pw, edgeWidth); // top
          ctx.fillStyle = `rgba(255,255,255,${leftAlpha})`; ctx.fillRect(px, py, edgeWidth, ph); // left
          ctx.fillStyle = `rgba(0,0,0,${bottomAlpha})`; ctx.fillRect(px, py + ph - edgeWidth, pw, edgeWidth); // bottom
          ctx.fillStyle = `rgba(0,0,0,${rightAlpha})`; ctx.fillRect(px + pw - edgeWidth, py, edgeWidth, ph); // right
        }

        ctx.restore();
      }
    }

    class Grid {
      constructor(cols, rows){
        this.cols = cols; this.rows = rows;
        this.bricks = [];
        this.resize();
      }
      resize(){
        const cssW = canvas.width / DPR; const cssH = canvas.height / DPR;
        const bw = Math.floor(cssW / this.cols);
        const bh = Math.floor(cssH / this.rows);
        this.brickW = bw; this.brickH = bh;
        this.bricks = [];
        for(let j=0;j<this.rows;j++){
          for(let i=0;i<this.cols;i++){
            const x = i*this.brickW;
            const y = j*this.brickH;
            this.bricks.push(new Brick(i,j,this.brickW,this.brickH,x,y));
          }
        }
      }
      triggerSingleRandom(){
        const idx = Math.floor(Math.random()*this.bricks.length);
        this.bricks[idx].trigger();
      }
      update(dt){ this.bricks.forEach(b=>b.update(dt)); }
      draw(ctx){
        ctx.fillStyle = BG_COLOR; ctx.fillRect(0,0,canvas.width,canvas.height);
        this.bricks.forEach(b=>b.draw(ctx,DPR));
      }
    }

    let grid = new Grid(BRICK_COLS, BRICK_ROWS);
    resize();

    let isPointerDown = false;
    canvas.addEventListener('pointerdown', (e)=>{ isPointerDown = true; canvas.setPointerCapture(e.pointerId); grid.triggerSingleRandom(); });
    canvas.addEventListener('pointermove', (e)=>{ if(isPointerDown) grid.triggerSingleRandom(); });
    canvas.addEventListener('pointerup', (e)=>{ isPointerDown=false; canvas.releasePointerCapture(e.pointerId); });
    canvas.addEventListener('pointerleave', ()=>{ isPointerDown=false; });

    let autoTimer = 0;
    let last = 0;
    function frame(ts){
      if(!last) last = ts;
      const dt = ts - last; last = ts;

      autoTimer += dt;
      if(autoTimer > 1000){
        autoTimer = 0;
        grid.triggerSingleRandom();
      }

      grid.update(dt);
      grid.draw(ctx);
      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);

  </script>
</body>
</html>
