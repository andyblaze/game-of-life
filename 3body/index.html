<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>3-body simulation (JavaScript)</title>
  <style>
    body { margin:0; background:#111; color:#ddd; font-family:system-ui,Segoe UI,Roboto,Arial; }
    #ui { position:fixed; left:8px; top:8px; z-index:10; }
    button { margin-right:6px; }
    canvas { display:block; width:100vw; height:100vh; }
  </style>
</head>
<body>
  <div id="ui">
    <button id="start">Start</button>
    <button id="pause">Pause</button>
    <button id="reset">Reset</button>
    <label>dt: <input id="dt" type="number" step="0.001" value="0.005" style="width:70px"></label>
  </div>
  <canvas id="c"></canvas>

<script>
class DeltaReport {
    static lastTime = performance.now();
    static frameCount = 0;
    static sum = 0;
    static min = 60;
    static max = 0;
    static elapsedSeconds = 0;
    static report = document.getElementById("fps-report");
    
    static log(timestamp) {
        this.frameCount++;
        const delta = (timestamp - this.lastTime) / 16.67;
        this.sum += delta;
        this.lastTime = timestamp;
        if ( this.frameCount === 120 ) { // every 2 seconds
            this.elapsedSeconds += 2;
            const minutes = Math.floor(this.elapsedSeconds / 60);
            const fps = parseInt(60 / (this.sum / this.frameCount));
            if ( fps < this.min ) this.min = fps; 
            if ( fps > this.max ) this.max = fps; 
            console.log("time", `${minutes}:${this.elapsedSeconds % 60}`, " fps=", fps, " min=", this.min, " max=", this.max);
            //this.report.innerText = fps + " " + this.min + " " + this.max;
            this.frameCount = 0;
            this.sum = 0;
        }
    }
}
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  function resize(){ canvas.width = innerWidth; canvas.height = innerHeight; }
  addEventListener('resize', resize);
  resize();

  // ---------- Simulation parameters ----------
  const G = 0.4;           // gravitational constant (unitless)
  const softening = 0.05;  // softening length to avoid singular forces
  let dt = parseFloat(document.getElementById('dt').value) || 0.005;

  // Body structure: {m, x:[x,y], v:[vx,vy], a:[ax,ay], color, trail:[]}
  let bodies = [];

function setExample(n = 10) {
  bodies = [];
  const cx = canvas.width / 2, cy = canvas.height / 2;

  for (let i = 0; i < n; i++) {
    // Random mass (heavier = slower drift)
    const mass = 100 + Math.random() * 200;

    // Random position anywhere on screen
    const x = Math.random() * canvas.width;
    const y = Math.random() * canvas.height;

    // Random velocity (small so they don't all fly off)
    const vx = (Math.random() - 0.5) * 1.5;
    const vy = (Math.random() - 0.5) * 1.5;

    // Random pastel-ish color
    const hue = Math.floor(Math.random() * 360);
    const color = `hsl(${hue}, 70%, 60%)`;

    bodies.push({
      m: mass,
      x: [x, y],
      v: [vx, vy],
      a: [0, 0],
      color: color,
      trail: [],
      pinned:false
    });
  // ðŸ’¥ Central "neutron star"
  const cx = canvas.width / 2, cy = canvas.height / 2;
  bodies.push({
    m: 2000,                 // much larger than others
    x: [cx, cy],
    v: [0, 0],                // fixed at center
    a: [0, 0],
    color: '#ffffff',         // bright white
    trail: [],
  pinned: true     // ðŸ‘ˆ new flag
  });
  }
}

  setExample(10);

  // ---------- Utilities ----------
  function vecAdd(a, b){ return [a[0]+b[0], a[1]+b[1]]; }
  function vecScale(a, s){ return [a[0]*s, a[1]*s]; }
  function vecSub(a,b){ return [a[0]-b[0], a[1]-b[1]]; }
  function vecLen(a){ return Math.hypot(a[0], a[1]); }

  // ---------- Force calculation ----------
  function computeAccelerations(bodies) {
    // reset accelerations
    for (let i=0;i<bodies.length;i++){ bodies[i].a[0]=0; bodies[i].a[1]=0; }
    // pairwise
    for (let i=0;i<bodies.length;i++){
      for (let j=i+1;j<bodies.length;j++){
        const bi = bodies[i], bj = bodies[j];
        const r = vecSub(bj.x, bi.x);
        const dist2 = r[0]*r[0] + r[1]*r[1] + softening*softening;
        const invDist = 1/Math.sqrt(dist2);
        const invDist3 = invDist*invDist*invDist; // 1/r^3
        const forceMag = G * invDist3;
        // acceleration contribution
        const ai = vecScale(r, forceMag * bj.m); // accel on i
        const aj = vecScale(r, -forceMag * bi.m); // accel on j (opposite)
        bi.a[0] += ai[0];
        bi.a[1] += ai[1];
        bj.a[0] += aj[0];
        bj.a[1] += aj[1];
      }
    }
  }

  // ---------- Integrator: velocity-Verlet ----------
  function velocityVerletStep(bodies, dt) {
    // x_{t+dt} = x_t + v_t*dt + 0.5*a_t*dt^2
    // v_{t+dt} = v_t + 0.5*(a_t + a_{t+dt})*dt
    // mass included in acceleration (we stored accelerations already scaled)
    // first half: update positions
    for (let b of bodies) {
      b.x[0] += b.v[0]*dt + 0.5*b.a[0]*dt*dt;
      b.x[1] += b.v[1]*dt + 0.5*b.a[1]*dt*dt;
    }
    // compute new accelerations at t+dt
    computeAccelerations(bodies);
    // update velocities
    for (let b of bodies) {
      b.v[0] += 0.5 * b.a[0] * dt; // note: because we overwrote a with a_{t+dt}, formula becomes v += 0.5*(a_old + a_new)*dt
      b.v[1] += 0.5 * b.a[1] * dt;
      // To use the true 0.5*(a_old + a_new) you'd need to store a_old; for simplicity we slightly modify:
      // A more correct implementation: store a_old before recomputeAccelerations and then do v += 0.5*(a_old + a_new)*dt
    }
    // To correct above simplification, implement properly:
    // (I'll implement properly below by computing with stored old accelerations.)
  }
function applyEdgeRepulsion(b, strength = 2000, repelDist = 100) {
  const w = canvas.width;
  const h = canvas.height;

  // Left edge
  const dxLeft = b.x[0];
  if (dxLeft < repelDist) {
    b.v[0] += (repelDist - dxLeft) / repelDist * strength * dt / b.m;
  }

  // Right edge
  const dxRight = w - b.x[0];
  if (dxRight < repelDist) {
    b.v[0] -= (repelDist - dxRight) / repelDist * strength * dt / b.m;
  }

  // Top edge
  const dyTop = b.x[1];
  if (dyTop < repelDist) {
    b.v[1] += (repelDist - dyTop) / repelDist * strength * dt / b.m;
  }

  // Bottom edge
  const dyBottom = h - b.x[1];
  if (dyBottom < repelDist) {
    b.v[1] -= (repelDist - dyBottom) / repelDist * strength * dt / b.m;
  }
}
  // Let's correct the integrator to store old accelerations:
  function velocityVerletStepCorrect(bodies, dt) {
    // store old accelerations
    const aOld = bodies.map(b=>[b.a[0], b.a[1]]);
    // update positions using old accel
    for (let i=0;i<bodies.length;i++){
      const b = bodies[i];
      if (b.pinned) continue;
      b.x[0] += b.v[0]*dt + 0.5*aOld[i][0]*dt*dt;
      b.x[1] += b.v[1]*dt + 0.5*aOld[i][1]*dt*dt; //wrapAround(b);
    }
     
    // compute new accelerations
    computeAccelerations(bodies);
    // update velocities with average accel
    for (let i=0;i<bodies.length;i++){
      const b = bodies[i];
      b.v[0] += 0.5*(aOld[i][0] + b.a[0]) * dt;
      b.v[1] += 0.5*(aOld[i][1] + b.a[1]) * dt;
        // Apply edge repulsion
  applyEdgeRepulsion(b, 2000, 120);
  // ---- conditional drag ----
  const vx = b.v[0], vy = b.v[1];
  const speed = Math.hypot(vx, vy);
  const maxSpeed = 5.0;  // tweak this threshold

  if (speed > maxSpeed) {
    const dragFactor = 0.95; // stronger = more braking (0.9..0.99 typical)
    b.v[0] *= dragFactor;
    b.v[1] *= dragFactor;
  }
    }
  }

  // initialize accelerations
  computeAccelerations(bodies);
function wrapAround(b) {
  const w = canvas.width;
  const h = canvas.height;
  if (b.x[0] < 0) b.x[0] += w;
  if (b.x[0] >= w) b.x[0] -= w;
  if (b.x[1] < 0) b.x[1] += h;
  if (b.x[1] >= h) b.x[1] -= h;
}
  // ---------- Rendering ----------
  function draw() {
    // fade background a bit for trails
    ctx.fillStyle = 'rgba(8,8,12,1)';
    ctx.fillRect(0,0,canvas.width, canvas.height);

    // draw bodies and trails
    for (let b of bodies) {
      // add to trail
      b.trail = b.trail || [];
      b.trail.push([b.x[0], b.x[1]]);
      if (b.trail.length > 1) b.trail.shift();

      // trail
      ctx.beginPath();
      for (let i=0;i<b.trail.length;i++){
        const p = b.trail[i];
        if (i===0) ctx.moveTo(p[0], p[1]); else ctx.lineTo(p[0], p[1]);
      }
      ctx.strokeStyle = b.color;
      ctx.globalAlpha = 0.6;
      ctx.stroke();
      ctx.globalAlpha = 1;

      // body
      ctx.beginPath();
      const radius = Math.max(3, Math.log10(b.m+1) * 3);
      ctx.fillStyle = b.color;
      ctx.arc(b.x[0], b.x[1], radius, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // ---------- Simulation loop ----------
  let running = false;
  let last = performance.now();
  const physicsStepsPerFrame = 13; // you can increase (e.g., 3) for stability if dt is large

  function stepFrame(ts) {
    if (!running) return;
    // read dt from input if changed
    dt = parseFloat(document.getElementById('dt').value) || dt;

    // perform fixed-number physics steps per animation frame
    for (let s=0;s<physicsStepsPerFrame;s++){
      // use smaller internal timestep if needed (substepping)
      const substeps = 1;
      const subdt = dt / substeps;
      for (let k=0;k<substeps;k++){
        // use correct velocity-Verlet
        velocityVerletStepCorrect(bodies, subdt);
      }
    }
    draw();
    DeltaReport.log(ts);
    requestAnimationFrame(stepFrame);
  }

  // ---------- Controls ----------
  document.getElementById('start').onclick = () => {
    if (!running) { running = true; requestAnimationFrame(stepFrame); }
  };
  document.getElementById('pause').onclick = () => { running = false; };
  document.getElementById('reset').onclick = () => { running=false; setExample(); computeAccelerations(bodies); draw(); };

  // draw initial state
  draw();

  // helpful: allow dragging bodies to reposition (optional)
  let drag = null;
  canvas.addEventListener('mousedown', e => {
    const mx = e.clientX, my = e.clientY;
    for (let b of bodies) {
      const r = vecSub([mx,my], b.x);
      if (vecLen(r) < 12) { drag = b; break; }
    }
  });
  canvas.addEventListener('mousemove', e => {
    if (drag && !running) { drag.x[0] = e.clientX; drag.x[1] = e.clientY; draw(); }
  });
  canvas.addEventListener('mouseup', ()=>{ drag = null; });

})();
</script>
</body>
</html>
