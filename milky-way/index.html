<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Galaxy Formation Demo</title>
<style>
  body { margin:0; overflow:hidden; background:black; }
  canvas { display:block; }
</style>
</head>
<body>
<canvas id="c"></canvas>

<script>
class DeltaReport {
    static lastTime = performance.now();
    static frameCount = 0;
    static sum = 0;
    static min = 60;
    static max = 0;
    static elapsedSeconds = 0;
    static report = document.getElementById("fps-report");
    
    static log(timestamp) {
        this.frameCount++;
        const delta = (timestamp - this.lastTime) / 16.67;
        this.sum += delta;
        this.lastTime = timestamp;
        if ( this.frameCount === 120 ) { // every 2 seconds
            this.elapsedSeconds += 2;
            const minutes = Math.floor(this.elapsedSeconds / 60);
            const fps = parseInt(60 / (this.sum / this.frameCount));
            if ( fps < this.min ) this.min = fps; 
            if ( fps > this.max ) this.max = fps; 
            console.log("time", `${minutes}:${this.elapsedSeconds % 60}`, " fps=", fps, " min=", this.min, " max=", this.max);
            //this.report.innerText = fps + " " + this.min + " " + this.max;
            this.frameCount = 0;
            this.sum = 0;
        }
    }
}

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
window.addEventListener('resize', resize);
resize();

class Particle {
    invisible(ctx) {
        return (
            this.x < 0 && this.x > ctx.canvas.width &&
            this.y < 0 && this.y > ctx.canvas.height
        );
    }
}
class BlackHole extends Particle {
    constructor(x=0, y=0, r=20, m=1) {
        super();
        this.x = x;
        this.y = y;
        this.radius = r;
        this.mass = m;
    }
    draw(ctx) {
        ctx.fillStyle = "#000000";
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
        ctx.fill();
    }
    setCoords(x, y) {
        this.x = x;
        this.y = y;    
    }
}
// ------------------ Parameters ------------------
const config = {
    numStars: 3000,
    numArms: 3, // number of spiral arms
    gravity: 2000,
    dt: 0.2,
    radialDamp: 0.01,
    perturbation: 0.05,
    patternAngle: 0,              // start aligned at 0 radians
    patternSpeed: 0.0008,         // radians per frame
    radiusMaxX: canvas.width / 2 * 0.95,
    radiusMaxY: canvas.height / 2 * 0.95,
    maxTrail: 2,
    canvasW: canvas.width,
    canvasH: canvas.height
};
  
class Galaxy {
    constructor(config, blackHole) {
        this.cfg = config;
        this.blackHole = blackHole;
        this.blackHole.setCoords(config.canvasW / 2 + 400, config.canvasH / 2);
        this.stars = [];
        this.init(config);
    }
    init(cfg) {
        // ------------------ Initialize stars with spiral velocity perturb ations ------------------  
        for ( let i = 0; i < cfg.numStars; i++ ) {
            const angle = Math.random() * 2 * Math.PI;
            const r = Math.random(); // normalized radius (0..1)
            // elliptical position
            const x = this.blackHole.x + r * cfg.radiusMaxX * Math.cos(angle);
            const y = this.blackHole.y + r * cfg.radiusMaxY * Math.sin(angle);
            // distance from center (used for velocity magnitude)
            const dx = x - this.blackHole.x, dy = y - this.blackHole.y;
            const dist = Math.hypot(dx, dy);
            // base circular orbit speed
            let v_mag = Math.sqrt(this.cfg.gravity * this.blackHole.mass / (dist + 1));
            // spiral perturbation (arm seeding)
            const perturb = Math.sin(cfg.numArms * angle + dist / 30) * cfg.perturbation;
            v_mag *= 0.8 + perturb;
            // tangential velocity direction
            const vx = -dy / dist * v_mag;
            const vy =  dx / dist * v_mag;
            // colors  
            let color = "#99ccff"; // bluish outer
            if ( dist < cfg.radiusMaxX*0.2 ) 
                color = '#ffcc88';    // warm core
            else if ( dist < cfg.radiusMaxX*0.6 ) 
                color = '#ffffff'; // white                       
            this.stars.push(new Star([x,y], [vx,vy], [0,0], color));
        }
    }
    update() {
        this.cfg.patternAngle += this.cfg.patternSpeed;
        for(const s of this.stars) 
            s.verletVelocityStep(this.cfg.dt, this.blackHole, this.cfg.radialDamp, this.cfg.gravity, this.cfg.patternAngle);
    }
    draw(ctx) {
        for( let s of this.stars ) {            
            s.draw(ctx);
        }
        this.blackHole.draw(ctx);
    }
}

class Star extends Particle {
    constructor(position, velocity, acceleration, color) {
        super();
        this.x = position[0];
        this.y = position[1];
        this.vx = velocity[0];
        this.vy = velocity[1];
        this.ax = acceleration[0];
        this.ay = acceleration[1];
        this.color = color;
        this.trail = [];
        this.maxTrail = 2;
    }
    getAcceleration() {
        return [this.ax, this.ay];
    }
    // ------------------ Integrator ------------------
    computeAcceleration(blackHole, g, patternAngle) {
    // --- gravitational acceleration from BH ---
    const rx = blackHole.x - this.x;
    const ry = blackHole.y - this.y;
    const r2 = rx*rx + ry*ry + 1;
    const invR3 = 1 / (r2 * Math.sqrt(r2));
    let ax = g * blackHole.mass * rx * invR3;
    let ay = g * blackHole.mass * ry * invR3;

    // --- spiral arm shepherding force ---
    const nArms = 3; // !!!!!!!!!!!!!!!!!!!!!!!!!! this is in galaxy !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    const armStrength = 0.6;     // tweak!
    const sigma = 0.35;          // angular width
    const windingScale = 400;     // looser/tighter arms
    const eps = 1e-6;

    // position relative to galactic center
    const dx = this.x - blackHole.x;
    const dy = this.y - blackHole.y;
    const r = Math.hypot(dx, dy) || eps;
    const theta = Math.atan2(dy, dx);

    // find nearest arm
    let bestDiff = 1e9;
    for (let m = 0; m < nArms; m++) {
        const armAngle = patternAngle + (2 * Math.PI * m) / nArms + r / windingScale;
        let angDiff = theta - armAngle;
        angDiff = ((angDiff + Math.PI) % (2 * Math.PI)) - Math.PI; // wrap to [-π,π]
        if (Math.abs(angDiff) < Math.abs(bestDiff)) bestDiff = angDiff;
    }

    // gaussian-shaped tangential force
    const weight = Math.exp(- (bestDiff*bestDiff) / (2 * sigma*sigma));
    const a_t = -armStrength * bestDiff * weight / (r + eps);

    // tangential unit vector
    const tx = -Math.sin(theta);
    const ty =  Math.cos(theta);

    ax += a_t * tx;
    ay += a_t * ty;

    // finally store
    this.ax = ax;
    this.ay = ay;
    }
    verletVelocityStep(dt, blackHole, radialDamp, g, patternAngle) { 
        const aOld = [...this.getAcceleration()];
        this.x += this.vx*dt + 0.5*aOld[0]*dt*dt;
        this.y += this.vy*dt + 0.5*aOld[1]*dt*dt;

        this.updateTrail();

        this.computeAcceleration(blackHole, g, patternAngle);
        this.vx += 0.5*(aOld[0]+this.ax)*dt;
        this.vy += 0.5*(aOld[1]+this.ay)*dt;

        // radial damping for circularization
        const rx = this.x-blackHole.x, ry = this.y-blackHole.y;
        const r = Math.hypot(rx, ry) || 1;
        const ux = rx/r, uy = ry/r;
        const vr = this.vx*ux + this.vy*uy;
        this.vx -= (1 - radialDamp)*vr*ux;
        this.vy -= (1 - radialDamp)*vr*uy;
    }
    updateTrail() {
        this.trail.push({"x": this.x, "y": this.y});
        if ( this.trail.length > this.maxTrail ) this.trail.shift();    
    }
    draw(ctx) {
        if ( this.invisible(ctx) ) return;
        ctx.lineWidth = 1;
        ctx.strokeStyle = this.color;
        const t = this.trail; 
        ctx.beginPath();
        ctx.moveTo(t[0].x, t[0].y);
        for( let i = 1; i < t.length; i++ ) {
            ctx.lineTo(t[i].x, t[i].y);
        }
        ctx.stroke();    
    }
}

class Model {
    constructor(config) {
        this.item = new Galaxy(config, new BlackHole());
    }
    update() {
        this.item.update();
        return this.item;
    }
}

const model = new Model(config);
//const galaxy = new Galaxy(config);
//galaxy.init();

  // ------------------ Render ------------------
class View {
    static draw(ctx, item) {
        ctx.fillStyle = "#000000";
        ctx.fillRect(0,0,canvas.width,canvas.height);
        item.draw(ctx);
    }
}

// ------------------ Animation loop ------------------
function step(ts) {
    const item = model.update();
    View.draw(ctx, item);
    DeltaReport.log(ts);
    requestAnimationFrame(step);
}
step();

</script>

</body>
</html>