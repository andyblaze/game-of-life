<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Galaxy Formation Demo</title>
<style>
  body { margin:0; overflow:hidden; background:black; }
  canvas { display:block; }
</style>
</head>
<body>
<canvas id="c"></canvas>

<script>
class DeltaReport {
    static lastTime = performance.now();
    static frameCount = 0;
    static sum = 0;
    static min = 60;
    static max = 0;
    static elapsedSeconds = 0;
    static report = document.getElementById("fps-report");
    
    static log(timestamp) {
        this.frameCount++;
        const delta = (timestamp - this.lastTime) / 16.67;
        this.sum += delta;
        this.lastTime = timestamp;
        if ( this.frameCount === 120 ) { // every 2 seconds
            this.elapsedSeconds += 2;
            const minutes = Math.floor(this.elapsedSeconds / 60);
            const fps = parseInt(60 / (this.sum / this.frameCount));
            if ( fps < this.min ) this.min = fps; 
            if ( fps > this.max ) this.max = fps; 
            console.log("time", `${minutes}:${this.elapsedSeconds % 60}`, " fps=", fps, " min=", this.min, " max=", this.max);
            //this.report.innerText = fps + " " + this.min + " " + this.max;
            this.frameCount = 0;
            this.sum = 0;
        }
    }
}
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  function resize() { canvas.width = innerWidth; canvas.height = innerHeight; }
  window.addEventListener('resize', resize);
  resize();

  // ------------------ Parameters ------------------
  const nStars = 3000;
  const nArms = 3; // number of spiral arms
  const G = 2000;
  const dt = 0.2;
  const radialDamp = 0.01;
  const particles = [];
  const cx = canvas.width/2 +200;
  const cy = canvas.height/2;
  let perturbation = 0.05;
const RmaxX = canvas.width/2 * 0.95;
const RmaxY = canvas.height/2 * 0.95;
  const maxTrail = 2;
  const blackHole = { "x": cx, "y": cy, "mass": 1 };
  
class Galaxy {
    constructor() {
        this.particles = [];
    }
    init(nArms, nStars, blackHole, perturbation, RmaxX, RmaxY) {
        // ------------------ Initialize stars with spiral velocity perturb ations ------------------  
        for (let i = 0; i < nStars; i++) {
            const angle = Math.random() * 2 * Math.PI;
            const r = Math.random(); // normalized radius (0..1)
            // elliptical position
            const x = blackHole.x + r * RmaxX * Math.cos(angle);
            const y = blackHole.y + r * RmaxY * Math.sin(angle);
            // distance from center (used for velocity magnitude)
            const dx = x - blackHole.x, dy = y - blackHole.y;
            const dist = Math.hypot(dx, dy);
            // base circular orbit speed
            let v_mag = Math.sqrt(G * blackHole.mass / (dist + 1));
            // spiral perturbation (arm seeding)
            const perturb = Math.sin(nArms * angle + dist / 30) * perturbation;
            v_mag *= 0.8 + perturb;
            // tangential velocity direction
            const vx = -dy / dist * v_mag;
            const vy =  dx / dist * v_mag;
            // colors  
            let color = "#99ccff"; // bluish outer
            if ( dist < RmaxX*0.2 ) 
                color = '#ffcc88';    // warm core
            else if ( dist < RmaxX*0.6 ) 
                color = '#ffffff'; // white                       
            this.particles.push(new Particle([x,y], [vx,vy], [0,0], color));
        }
    }
    draw(ctx) {
        for( let p of this.particles ) {            
            p.draw(ctx);
        }
        // black hole
        ctx.fillStyle = "#000000";
        ctx.beginPath();
        ctx.arc(cx, cy, 20, 0, 2 * Math.PI); // radius ~20px, tweak as needed
        ctx.fill();
    }
}

class Particle {
    constructor(position, velocity, acceleration, color) {
        this.x = position;
        this.v = velocity;
        this.a = acceleration;
        this.color = color;
        this.trail = [];
        this.maxTrail = 2;
    }
    invisible(ctx) {
        return (
            this.x[0] < 0 && this.x[0] > ctx.canvas.width &&
            this.x[1] < 0 && this.x[1] > ctx.canvas.height
        );
    }
    // ------------------ Integrator ------------------
    computeAcceleration(blackHole, g) {
        const rx = blackHole.x - this.x[0];
        const ry = blackHole.y - this.x[1];
        const r2 = rx*rx + ry*ry + 1;
        const invR3 = 1 / (r2 * Math.sqrt(r2));
        this.a[0] = g*blackHole.mass*rx*invR3;
        this.a[1] = g*blackHole.mass*ry*invR3;
    }
    verletVelocityStep(dt, blackHole, radialDamp, g) { 
        const aOld = [...this.a];
        this.x[0] += this.v[0]*dt + 0.5*aOld[0]*dt*dt;
        this.x[1] += this.v[1]*dt + 0.5*aOld[1]*dt*dt;

        this.updateTrail();

        this.computeAcceleration(blackHole, g);
        this.v[0] += 0.5*(aOld[0]+this.a[0])*dt;
        this.v[1] += 0.5*(aOld[1]+this.a[1])*dt;

        // radial damping for circularization
        const rx = this.x[0]-blackHole.x, ry = this.x[1]-blackHole.y;
        const r = Math.hypot(rx, ry) || 1;
        const ux = rx/r, uy = ry/r;
        const vr = this.v[0]*ux + this.v[1]*uy;
        this.v[0] -= (1 - radialDamp)*vr*ux;
        this.v[1] -= (1 - radialDamp)*vr*uy;
    }
    updateTrail() {
        this.trail.push([this.x[0], this.x[1]]);
        if ( this.trail.length > this.maxTrail ) this.trail.shift();    
    }
    draw(ctx) {
        if ( this.invisible(ctx) ) return;
        ctx.lineWidth = 1;
        ctx.strokeStyle = this.color;
        const t = this.trail; 
        ctx.beginPath();
        ctx.moveTo(t[0][0], t[0][1]);
        for( let i = 1; i < t.length; i++ ) {
            ctx.lineTo(t[i][0], t[i][1]);
        }
        ctx.stroke();    
    }
}

function init(nArms, nStars, blackHole, perturbation, RmaxX, RmaxY) {
  // ------------------ Initialize stars with spiral velocity perturb ations ------------------
  
for (let i = 0; i < nStars; i++) {
  const angle = Math.random() * 2 * Math.PI;
  const r = Math.random(); // normalized radius (0..1)

  // elliptical position
  const x = blackHole.x + r * RmaxX * Math.cos(angle);
  const y = blackHole.y + r * RmaxY * Math.sin(angle);

  // distance from center (used for velocity magnitude)
  const dx = x - blackHole.x, dy = y - blackHole.y;
  const dist = Math.hypot(dx, dy);

  // base circular orbit speed
  let v_mag = Math.sqrt(G * blackHole.m / (dist + 1));

  // spiral perturbation (arm seeding)
  const perturb = Math.sin(nArms * angle + dist / 30) * perturbation;
  v_mag *= 0.8 + perturb;

  // tangential velocity direction
  const vx = -dy / dist * v_mag;
  const vy =  dx / dist * v_mag;
  
let color = "#99ccff"; // bluish outer
if ( dist < RmaxX*0.2 ) 
    color = '#ffcc88';    // warm core
else if ( dist < RmaxX*0.6 ) 
    color = '#ffffff'; // white
                    


  particles.push(new Particle([x,y], [vx,vy], [0,0], color));
  }
}
const galaxy = new Galaxy();
galaxy.init(nArms, nStars, blackHole, perturbation, RmaxX, RmaxY);
//init(nArms, nStars, blackHole, perturbation, RmaxX, RmaxY);
  // ------------------ Integrator ------------------
  /*function computeAcceleration(p, bh, g) {
    const rx = bh.x - p.x[0];
    const ry = bh.y - p.x[1];
    const r2 = rx*rx + ry*ry + 1;
    const invR3 = 1 / (r2 * Math.sqrt(r2));
    return [g*bh.m*rx*invR3, g*bh.m*ry*invR3];
  }*/

  /*function verletVelocityStep(p, dt, bh, rd) { 
    const aOld = [...p.a];
    p.x[0] += p.v[0]*dt + 0.5*aOld[0]*dt*dt;
    p.x[1] += p.v[1]*dt + 0.5*aOld[1]*dt*dt;

    p.updateTrail();

    p.computeAcceleration(blackHole, G);
    p.v[0] += 0.5*(aOld[0]+p.a[0])*dt;
    p.v[1] += 0.5*(aOld[1]+p.a[1])*dt;

    // radial damping for circularization
    const rx = p.x[0]-blackHole.x, ry = p.x[1]-blackHole.y;
    const r = Math.hypot(rx, ry) || 1;
    const ux = rx/r, uy = ry/r;
    const vr = p.v[0]*ux + p.v[1]*uy;
    p.v[0] -= (1 - radialDamp)*vr*ux;
    p.v[1] -= (1 - radialDamp)*vr*uy;
  }*/


  // ------------------ Render ------------------
  function draw() {
    ctx.fillStyle = "#000000";
    ctx.fillRect(0,0,canvas.width,canvas.height);




    //for(let p of galaxy.particles){
        //if ( p.invisible()) continue;  // skip drawing off-screen
        galaxy.draw(ctx);

  // --- star head ---
  //const headSize = p.size;
  // => closer stars smaller, outer stars can be a bit bigger, but max 3px
  //ctx.fillStyle = p.color;
  //ctx.beginPath();
  //ctx.arc(p.x[0], p.x[1], headSize, 0, 2 * Math.PI);
  //ctx.fill();
    //}
  // black hole
//ctx.fillStyle = "black";
//ctx.beginPath();
//ctx.arc(cx, cy, 20, 0, 2 * Math.PI); // radius ~20px, tweak as needed
//ctx.fill();
  }

  // ------------------ Animation loop ------------------
  function step(ts) {
    for(let p of galaxy.particles) 
        p.verletVelocityStep(dt, blackHole, radialDamp, G);
    draw(ctx);
    DeltaReport.log(ts);
    requestAnimationFrame(step);
  }
  step();
})();
</script>

</body>
</html>