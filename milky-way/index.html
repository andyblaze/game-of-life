<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Galaxy Formation Demo</title>
<style>
  body { margin:0; overflow:hidden; background:black; }
  canvas { display:block; }
</style>
</head>
<body>
<canvas id="c"></canvas>

<script>
class DeltaReport {
    static lastTime = performance.now();
    static frameCount = 0;
    static sum = 0;
    static min = 60;
    static max = 0;
    static elapsedSeconds = 0;
    static report = document.getElementById("fps-report");
    
    static log(timestamp) {
        this.frameCount++;
        const delta = (timestamp - this.lastTime) / 16.67;
        this.sum += delta;
        this.lastTime = timestamp;
        if ( this.frameCount === 120 ) { // every 2 seconds
            this.elapsedSeconds += 2;
            const minutes = Math.floor(this.elapsedSeconds / 60);
            const fps = parseInt(60 / (this.sum / this.frameCount));
            if ( fps < this.min ) this.min = fps; 
            if ( fps > this.max ) this.max = fps; 
            console.log("time", `${minutes}:${this.elapsedSeconds % 60}`, " fps=", fps, " min=", this.min, " max=", this.max);
            //this.report.innerText = fps + " " + this.min + " " + this.max;
            this.frameCount = 0;
            this.sum = 0;
        }
    }
}

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
window.addEventListener('resize', resize);
resize();

class Particle {
    invisible(ctx) {
        return (
            this.x < 0 && this.x > ctx.canvas.width &&
            this.y < 0 && this.y > ctx.canvas.height
        );
    }
}
class BlackHole extends Particle {
    constructor(x=0, y=0, r=20, m=1) {
        super();
        this.x = x;
        this.y = y;
        this.radius = r;
        this.mass = m;
    }
    draw(ctx) {
        ctx.fillStyle = "#000000";
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
        ctx.fill();
    }
    moveX(amount) {
        this.x += amount;
    }
    setCoords(x, y) {
        this.x = x;
        this.y = y;    
    }
}
// ------------------ Parameters ------------------
const config = {
    numStars: 3000,
    numArms: 3, // number of spiral arms
    gravity: 2000,
    dt: 0.2,
    radialDamp: 0.01,
    perturbation: 0.05,
    // --- spiral arm shepherding force ---
    armStrength: 0.6,     // 0.3 to 1.5 suggested. low & arms fade, high & stars becom "lanes"
    sigma: 0.2,          // 0.2 to 0.5 suggested. low = sharper, high = fuzzy arms
    windingScale: 40,     // smaller = whirlpool, larger = sweeping
    patternAngle: 0,              // start aligned at 0 radians
    patternSpeed: 0.0008,         // radians per frame
    
    // Plummer Sphere Halo potential.  keeps stars towards Black Hole
    haloMass: 10,
    haloRadius: 400,
    
    radiusMaxX: canvas.width / 2 * 0.95,
    radiusMaxY: canvas.height / 2 * 0.95,
    maxTrail: 2,
    canvasW: canvas.width,
    canvasH: canvas.height
};
  
class Galaxy {
    constructor(id, config, blackHole) {
        this.id = id;
        this.cfg = config;
        this.blackHole = blackHole;
        //this.blackHole.setCoords(config.canvasW / 2 + 400, config.canvasH / 2);
        this.stars = [];
        this.init(config);
    }
    init(cfg) {
        // ------------------ Initialize stars with spiral velocity perturbations ------------------  
        for ( let i = 0; i < cfg.numStars; i++ ) {
            const angle = Math.random() * 2 * Math.PI;
            const r = Math.random(); // normalized radius (0..1)
            // elliptical position
            const x = this.blackHole.x + r * cfg.radiusMaxX * Math.cos(angle);
            const y = this.blackHole.y + r * cfg.radiusMaxY * Math.sin(angle);
            // distance from center (used for velocity magnitude)
            const dx = x - this.blackHole.x, dy = y - this.blackHole.y;
            const dist = Math.hypot(dx, dy);
            // base circular orbit speed
            let v_mag = Math.sqrt(this.cfg.gravity * this.blackHole.mass / (dist + 1));
            // spiral perturbation (arm seeding)
            const perturb = Math.sin(cfg.numArms * angle + dist / 30) * cfg.perturbation;
            v_mag *= 0.8 + perturb;
            // tangential velocity direction
            const vx = -dy / dist * v_mag;
            const vy =  dx / dist * v_mag;
            // colors  
            let color = "#99ccff"; // bluish outer
            if ( dist < cfg.radiusMaxX*0.2 ) 
                color = '#ffcc88';    // warm core
            else if ( dist < cfg.radiusMaxX*0.6 ) 
                color = '#ffffff'; // white                       
            this.stars.push(new Star([x,y], [vx,vy], [0,0], color));
        }
    }
    update() {
        this.cfg.patternAngle += this.cfg.patternSpeed;
        for(const s of this.stars) 
            s.verletVelocityStep(this.cfg, this.blackHole);
    }
    draw(ctx) {
        for( let s of this.stars ) {            
            s.draw(ctx);
        }
        //this.blackHole.moveX(-0.01);
        this.blackHole.draw(ctx);
    }
}

class Star extends Particle {
    constructor(position, velocity, acceleration, color) {
        super();
        this.x = position[0];
        this.y = position[1];
        this.vx = velocity[0];
        this.vy = velocity[1];
        this.ax = acceleration[0];
        this.ay = acceleration[1];
        this.color = color;
        this.trail = [];
        this.maxTrail = 2;
    }
    getAcceleration() {
        return [this.ax, this.ay];
    }
    // ------------------ Integrator ------------------
    computeBHAcceleration(cfg, bh) {
        const rx = bh.x - this.x;
        const ry = bh.y - this.y;
        const r2 = rx*rx + ry*ry + 1; // softening
        const invR3 = 1 / (r2 * Math.sqrt(r2));
        return [
            cfg.gravity * bh.mass * rx * invR3,
            cfg.gravity * bh.mass * ry * invR3
        ];
    } 
    computeHaloAcceleration(cfg, bh) {
        const dx = this.x - bh.x;
        const dy = this.y - bh.y;
        const r2_halo = dx*dx + dy*dy + cfg.haloRadius*cfg.haloRadius;
        const invR3 = 1 / Math.pow(r2_halo, 1.5);
        return [
            cfg.gravity * cfg.haloMass * -dx * invR3,
            cfg.gravity * cfg.haloMass * -dy * invR3
        ];
    } 
    computeSpiralAcceleration(cfg, bh) {
        const eps = 1e-6;
        const dx = this.x - bh.x;
        const dy = this.y - bh.y;
        const r = Math.hypot(dx, dy) || eps;
        const theta = Math.atan2(dy, dx);

        // find nearest arm
        let bestDiff = 1e9;
        for (let m = 0; m < cfg.numArms; m++) {
            const armAngle = cfg.patternAngle + (2 * Math.PI * m) / cfg.numArms + r / cfg.windingScale;
            let angDiff = theta - armAngle;
            angDiff = ((angDiff + Math.PI) % (2 * Math.PI)) - Math.PI; // wrap [-π,π]
            if (Math.abs(angDiff) < Math.abs(bestDiff)) bestDiff = angDiff;
        }

        const weight = Math.exp(- (bestDiff*bestDiff) / (2 * cfg.sigma * cfg.sigma));
        const a_t = -cfg.armStrength * bestDiff * weight / (r + eps);

        return [
            a_t * -Math.sin(theta), // tx
            a_t *  Math.cos(theta)  // ty
        ];
    }
    computeAcceleration(cfg, blackHole) { // galaxy.cfg
        let [ax, ay] = this.computeBHAcceleration(cfg, blackHole);
        const [ahx, ahy] = this.computeHaloAcceleration(cfg, blackHole);
        ax += ahx;
        ay += ahy;

        const [asx, asy] = this.computeSpiralAcceleration(cfg, blackHole);
        ax += asx;
        ay += asy;

        this.ax = ax;
        this.ay = ay;
    }
    verletVelocityStep(cfg, blackHole) { // galaxy.cfg 
        const aOld = [...this.getAcceleration()];
        this.x += this.vx * cfg.dt + 0.5 * aOld[0] * cfg.dt * cfg.dt;
        this.y += this.vy * cfg.dt + 0.5 * aOld[1] * cfg.dt * cfg.dt;

        this.updateTrail();

        this.computeAcceleration(cfg, blackHole);
        this.vx += 0.5 * (aOld[0] + this.ax) * cfg.dt;
        this.vy += 0.5 * (aOld[1] + this.ay) * cfg.dt;

        // radial damping for circularization
        const rx = this.x - blackHole.x, ry = this.y - blackHole.y;
        const r = Math.hypot(rx, ry) || 1;
        const ux = rx / r, uy = ry / r;
        const vr = this.vx * ux + this.vy * uy;
        this.vx -= (1 - cfg.radialDamp) * vr * ux;
        this.vy -= (1 - cfg.radialDamp) * vr * uy;
    }
    updateTrail() {
        this.trail.push({"x": this.x, "y": this.y});
        if ( this.trail.length > this.maxTrail ) this.trail.shift();    
    }
    draw(ctx) {
        if ( this.invisible(ctx) ) return;
        ctx.lineWidth = 1;
        ctx.strokeStyle = this.color;
        const t = this.trail; 
        ctx.beginPath();
        ctx.moveTo(t[0].x, t[0].y);
        for( let i = 1; i < t.length; i++ ) {
            ctx.lineTo(t[i].x, t[i].y);
        }
        ctx.stroke();    
    }
}

class Model {
    constructor(config) {
        this.item = new Galaxy("crashee", config, new BlackHole(config.canvasW / 2 + 400, config.canvasH / 2));
    }
    update() {
        this.item.update();
        return this.item;
    }
}

const model = new Model(config);
//const galaxy = new Galaxy(config);
//galaxy.init();

  // ------------------ Render ------------------
class View {
    static draw(ctx, item) {
        ctx.fillStyle = "#000000";
        ctx.fillRect(0,0,canvas.width,canvas.height);
        item.draw(ctx);
    }
}

// ------------------ Animation loop ------------------
function animate(timestamp) {
    const item = model.update();
    View.draw(ctx, item);
    DeltaReport.log(timestamp);
    requestAnimationFrame(animate);
}
animate();

</script>

</body>
</html>