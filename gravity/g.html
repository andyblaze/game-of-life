<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Gravity Sandbox</title>
<style>
    html, body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: black;
    }
    canvas {
        display: block;
    }
</style>
</head>
<body>
<canvas id="sandbox"></canvas>
<script>
class DeltaReport {
    static lastTime = performance.now();
    static startTime = performance.now();
    static frameCount = 0;
    static sum = 0;
    static min = 60;
    static max = 0;
    static timeSum = 0; // total ms of frame times (not normalised)

    static log(timestamp) {
        this.frameCount++;
        const deltaTime = timestamp - this.lastTime; // ms since last frame
        const delta = deltaTime / 16.67; // normalised to 60fps

        this.sum += delta;
        this.timeSum += deltaTime;
        this.lastTime = timestamp;

        if (this.frameCount === 120) { // ~2 seconds at 60fps
            const fps = parseInt(60 / (this.sum / this.frameCount));
            if (fps < this.min) this.min = fps; 
            if (fps > this.max) this.max = fps; 

            const avgFrameTime = this.timeSum / this.frameCount; // ms
            const totalSeconds = Math.floor((timestamp - this.startTime) / 1000);
            const minutes = Math.floor(totalSeconds / 60).toString().padStart(2, "0");
            const seconds = (totalSeconds % 60).toString().padStart(2, "0");
            const elapsed = minutes + ":" + seconds;

            console.log(
                "fps", fps,
                "min=", this.min,
                "max=", this.max,
                "avgFrame=", avgFrameTime.toFixed(2) + "ms",
                "elapsed=", elapsed
            );

            // reset accumulators
            this.frameCount = 0;
            this.sum = 0;
            this.timeSum = 0;
        }
    }
}
const canvas = document.getElementById('sandbox');
const ctx = canvas.getContext('2d');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// --- Particle class ---
class Particle {
    constructor(x, y, color="rgb(0,255,0)") {
        this.x = x;
        this.y = y;
        this.vx = (Math.random()-0.5) * 2;
        this.vy = (Math.random()-0.5) * 2;
        this.color = color;
        this.drag = 0.995;
    }

    update(attractors) {
        for (let a of attractors) {
            let dx = a.x - this.x;
            let dy = a.y - this.y;
            let dist2 = dx*dx + dy*dy;
            if (dist2 < 1) dist2 = 1; // avoid divide by 0
            let force = a.strength / dist2;
            this.vx += force * dx;
            this.vy += force * dy;
            // Apply drag
            this.vx *= this.drag;
            this.vy *= this.drag;
        }
        this.x += this.vx;
        this.y += this.vy;

        // wrap around screen
        if (this.x < 0) this.x += canvas.width;
        if (this.x > canvas.width) this.x -= canvas.width;
        if (this.y < 0) this.y += canvas.height;
        if (this.y > canvas.height) this.y -= canvas.height;
    }

    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 2, 0, Math.PI*2);
        ctx.fill();
    }
}
function lerp(a, b, t) {
    return a + (b - a) * t;
}

function lerpColor(c1, c2, t) {
    return {
        r: lerp(c1.r, c2.r, t),
        g: lerp(c1.g, c2.g, t),
        b: lerp(c1.b, c2.b, t)
    };
}
const COLOR_NEG = { r: 0,   g: 120, b: 255 }; // repulsor (blue)
const COLOR_ZERO = { r: 230, g: 230, b: 230 }; // neutral (white-ish)
const COLOR_POS = { r: 255, g: 60,  b: 60  }; // attractor (red)

function mt_rand(min, max) {
    // Swap if parameters are reversed
    if (max < min) [min, max] = [max, min];

    return Math.floor(Math.random() * (max - min + 1)) + min;
}
function mt_rand_excluding_gap(min1, max1, min2, max2) {
    // choose which range (50/50)
    if (Math.random() < 0.5) {
        return Math.floor(Math.random() * (max1 - min1 + 1)) + min1;
    } else {
        return Math.floor(Math.random() * (max2 - min2 + 1)) + min2;
    }
}
// --- Attractor class ---
class Attractor {
    constructor(x, y, strength) {
        this.x = x;
        this.y = y;
        this.vX = Math.random() - 0.9;
        this.vY = Math.random() - 0.9;
        if ( Math.random() < 0.5 ) {
            this.vX = -this.vX;
            this.vY = -this.vY;
        }
        this.strength = strength; // positive = attract, negative = repel
        this.baseStrength = strength;
        if ( strength < 0 ) {
            this.color = COLOR_NEG;
        }
        else {
            this.color = COLOR_POS;
        }
        this.period = Math.floor(Math.random() * 30000) + 20000;
        this.startTime = performance.now();
    }

    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 6, 0, Math.PI*2);
        ctx.fill();
    }
    update() {
        let tmp;
        if ( Math.random() < 0.01 ) {
            tmp = this.strength;
            this.strength = -10;
        }
        this.strength = tmp;
        const t = performance.now() - this.startTime;
        this.strength = this.baseStrength * Math.sin((t / this.period) * 2 * Math.PI);
        // Normalize to 0..1
        const norm = (this.strength / this.baseStrength + 1) / 2;
        // Now lerp between negative → zero → positive
        let c;
        if (norm < 0.5) {
            // Negative half: BLUE → WHITE
            const t2 = norm / 0.5; // map 0..0.5 → 0..1
            c = lerpColor(COLOR_NEG, COLOR_ZERO, t2);
        } else {
            // Positive half: WHITE → RED
            const t2 = (norm - 0.5) / 0.5; // map 0.5..1 → 0..1
            c = lerpColor(COLOR_ZERO, COLOR_POS, t2);
        }

        this.color = `rgb(${c.r|0},${c.g|0},${c.b|0})`; 
        
        this.x += this.vX;
        this.y += this.vY;
        // wrap around screen
        if (this.x < 0) this.x += canvas.width;
        if (this.x > canvas.width) this.x -= canvas.width;
        if (this.y < 0) this.y += canvas.height;
        if (this.y > canvas.height) this.y -= canvas.height;
    }
}

// --- setup particles & attractors ---
const particles = [];
for ( let i = 0; i < 900; i++ ) {
    particles.push(new Particle(mt_rand(0, canvas.width), mt_rand(0, canvas.height)));
}

const attractors = [];
for ( let i = 0; i < 15; i++ ) {
    attractors.push(new Attractor(
        mt_rand(0, canvas.width), 
        mt_rand(0, canvas.height), 
        mt_rand_excluding_gap(-10, -3, 3, 10)
    ));
}

// --- animation loop ---
function animate(timestamp) {
    // semi-transparent background to leave trails
    ctx.fillStyle = "rgba(0,0,0,0.05)";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    for (let a of attractors) { a.update(); a.draw(ctx); }
    for (let p of particles) {
        p.update(attractors);
        p.draw(ctx);
    }
    DeltaReport.log(timestamp);
    requestAnimationFrame(animate);
}

animate();
</script>
</body>
</html>
