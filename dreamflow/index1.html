<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Dreamflow — CPU optimized</title>
<style>
  html,body{height:100%;margin:0;background:#050507;color:#eaf2ff;font-family:system-ui,Segoe UI,Roboto,Arial;}
  #ui{position:fixed;left:12px;top:12px;background:rgba(3,6,9,0.6);padding:10px;border-radius:10px;z-index:20;width:320px;}
  label{display:block;margin-top:6px;font-size:13px}
  input[type=range]{width:100%}
  button{margin-top:8px;margin-right:6px}
  .row{display:flex;gap:6px;align-items:center}
  .val{min-width:56px;text-align:right;font-family:monospace}
  canvas{display:block;width:100%;height:100vh}
</style>
</head>
<body>
<div id="ui">
  <strong>Dreamflow — CPU optimized</strong>
  <div class="row" style="margin-top:6px">
    <button id="btnPause">Pause</button>
    <button id="btnSeed">Seed</button>
    <button id="btnClear">Clear</button>
    <div style="flex:1"></div>
    <div class="val" id="fps">— fps</div>
  </div>

  <label>Grid (W × H)</label>
  <div class="row">
    <input id="gridW" type="number" min="80" max="960" value="480" style="width:92px">
    <input id="gridH" type="number" min="48" max="540" value="270" style="width:92px">
    <button id="applyGrid">Apply</button>
  </div>

  <label>Diffusion <span class="val" id="diffVal">0.26</span></label>
  <input id="diff" type="range" min="0" max="100" value="26">

  <label>Advection <span class="val" id="advVal">0.40</span></label>
  <input id="adv" type="range" min="0" max="200" value="40">

  <label>Damping <span class="val" id="dampVal">0.008</span></label>
  <input id="damp" type="range" min="0" max="50" value="8">

  <label>Excite/sec <span class="val" id="excVal">8</span></label>
  <input id="exc" type="range" min="0" max="60" value="8">

  <small style="display:block;margin-top:6px">Nearest-neighbor advection is used for speed. Click & drag to paint.</small>
</div>

<canvas id="main"></canvas>

<script>
(() => {
  // DOM
  const canvas = document.getElementById('main');
  const ctx = canvas.getContext('2d', { alpha: false });

  // UI
  const btnPause = document.getElementById('btnPause');
  const btnSeed  = document.getElementById('btnSeed');
  const btnClear = document.getElementById('btnClear');
  const gridWIn = document.getElementById('gridW');
  const gridHIn = document.getElementById('gridH');
  const applyGridBtn = document.getElementById('applyGrid');
  const diffRange = document.getElementById('diff');
  const advRange = document.getElementById('adv');
  const dampRange = document.getElementById('damp');
  const excRange = document.getElementById('exc');
  const diffVal = document.getElementById('diffVal');
  const advVal = document.getElementById('advVal');
  const dampVal = document.getElementById('dampVal');
  const excVal = document.getElementById('excVal');
  const fpsLabel = document.getElementById('fps');
const fadeVal = document.createElement("span");
fadeVal.textContent = "0.90";
const fadeLabel = document.createElement("label");
fadeLabel.textContent = "Fade ";
fadeLabel.appendChild(fadeVal);
const fadeRange = document.createElement("input");
fadeRange.type = "range";
fadeRange.min = "70"; fadeRange.max = "99"; fadeRange.value = "90";
fadeRange.style.width = "100%";
fadeRange.addEventListener("input",()=>{
  fadeStrength = parseFloat(fadeRange.value)/100;
  fadeVal.textContent = fadeStrength.toFixed(2);
});
document.getElementById("ui").appendChild(fadeLabel);
document.getElementById("ui").appendChild(fadeRange);

  // Simulation parameters (start values)
  let W = parseInt(gridWIn.value,10), H = parseInt(gridHIn.value,10);
  let diffusion = parseFloat(diffRange.value)/100;
  let advection = parseFloat(advRange.value)/100;
  let damping = parseFloat(dampRange.value)/1000;
  let excitationRate = parseFloat(excRange.value);

  // Buffers & precomputed indices
  let size = 0;                // number of cells
  let simA = null, simB = null;// Float32Array length size*3 (rgb)
  let neighbors3 = null;       // Int32Array length size*9 (neighborIndex*3)
  let hue = null;              // per-cell hue bias
  let imageData = null;        // ImageData for low-res drawing
  const off = document.createElement('canvas');
  const offCtx = off.getContext('2d');

  // runtime
  let running = true;
  let lastFrame = performance.now();
  let fpsTime = performance.now();
  let frameCount = 0;
  let accumExc = 0;
// persistence buffer
let accumImage = null;


let fadeStrength = 0.90; // how much of new frame blends in (0.7=long trails, 0.95=fast fade)


  // small helpers
  const clamp = (v,a,b) => v < a ? a : (v > b ? b : v);

  // Resize main canvas for DPR
  function resizeCanvas(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width  = Math.round(window.innerWidth * dpr);
    canvas.height = Math.round(window.innerHeight * dpr);
    canvas.style.width  = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    ctx.imageSmoothingEnabled = true;
  }

  // Precompute neighbor indices * 3 (so we can fetch rgb quickly)
  function precomputeNeighbors(){
    // neighbors order: (xm1,ym1),(x,ym1),(xp1,ym1),(xm1,y),(x,y),(xp1,y),(xm1,yp1),(x,yp1),(xp1,yp1)
    const nPerCell = 9;
    neighbors3 = new Int32Array(size * nPerCell);
    for (let y = 0; y < H; y++){
      const ym1 = (y>0) ? y-1 : 0;
      const yp1 = (y < H-1) ? y+1 : H-1;
      for (let x = 0; x < W; x++){
        const xm1 = (x>0) ? x-1 : 0;
        const xp1 = (x < W-1) ? x+1 : W-1;
        const baseCell = y * W + x;
        const cellIndex = baseCell * nPerCell;
        // fill nine neighbors' base*3
        neighbors3[cellIndex + 0] = (ym1 * W + xm1) * 3;
        neighbors3[cellIndex + 1] = (ym1 * W + x  ) * 3;
        neighbors3[cellIndex + 2] = (ym1 * W + xp1) * 3;
        neighbors3[cellIndex + 3] = (y   * W + xm1) * 3;
        neighbors3[cellIndex + 4] = (y   * W + x  ) * 3; // center
        neighbors3[cellIndex + 5] = (y   * W + xp1) * 3;
        neighbors3[cellIndex + 6] = (yp1 * W + xm1) * 3;
        neighbors3[cellIndex + 7] = (yp1 * W + x  ) * 3;
        neighbors3[cellIndex + 8] = (yp1 * W + xp1) * 3;
      }
    }
  }

  // Allocate arrays for current grid size
  function alloc(){
    size = W * H;
    simA = new Float32Array(size * 3);
    simB = new Float32Array(size * 3);
    hue = new Float32Array(size);
    for (let i=0;i<size;i++) hue[i] = Math.random();
    precomputeNeighbors();
    off.width = W;
    off.height = H;
    imageData = offCtx.createImageData(W, H);

  }

  // Nearest-neighbor sample (fast) - returns idx*3 base (integer)
  function nearestSampleBase(x, y){
    // clamp to grid
    const ix = (x < 0) ? 0 : (x >= W ? W-1 : (x|0));
    const iy = (y < 0) ? 0 : (y >= H ? H-1 : (y|0));
    return (iy * W + ix) * 3;
  }

  // One simulation step (hot loop optimized)
  function step(){
    const inv9 = 1/9;
    const A = simA, B = simB, N3 = neighbors3;
    const nPerCell = 9;

    // local copies of params for JIT friendliness
    const diff = diffusion;
    const adv = advection;
    const damp = damping;

    // iterate every cell by index i (cell index)
    // we will compute neighbor base offsets using neighbors3
    for (let cell = 0, nBase = 0; cell < size; cell++, nBase += nPerCell){
      // neighbor base addresses (already multiplied by 3)
      // note: N3[nBase + k] is the starting index in A for that neighbor's R component
      const nb0 = N3[nBase + 0], nb1 = N3[nBase + 1], nb2 = N3[nBase + 2],
            nb3 = N3[nBase + 3], nb4 = N3[nBase + 4], nb5 = N3[nBase + 5],
            nb6 = N3[nBase + 6], nb7 = N3[nBase + 7], nb8 = N3[nBase + 8];

      // sum R channel across 9 neighbors
      // reading sequentially from A, which is Float32Array
      const rSum = A[nb0] + A[nb1] + A[nb2] + A[nb3] + A[nb4] + A[nb5] + A[nb6] + A[nb7] + A[nb8];
      const gSum = A[nb0+1] + A[nb1+1] + A[nb2+1] + A[nb3+1] + A[nb4+1] + A[nb5+1] + A[nb6+1] + A[nb7+1] + A[nb8+1];
      const bSum = A[nb0+2] + A[nb1+2] + A[nb2+2] + A[nb3+2] + A[nb4+2] + A[nb5+2] + A[nb6+2] + A[nb7+2] + A[nb8+2];

      // average
      const avgR = rSum * inv9;
      const avgG = gSum * inv9;
      const avgB = bSum * inv9;

      // compute luminance gradient using left/right/up/down neighbors (nearest)
      // left neighbor base = nb3, right = nb5, up = nb1, down = nb7
      const lumC = (A[nb4] + A[nb4+1] + A[nb4+2]) / 3;
      const lumL = (A[nb3] + A[nb3+1] + A[nb3+2]) / 3;
      const lumR = (A[nb5] + A[nb5+1] + A[nb5+2]) / 3;
      const lumU = (A[nb1] + A[nb1+1] + A[nb1+2]) / 3;
      const lumD = (A[nb7] + A[nb7+1] + A[nb7+2]) / 3;

      const gx = (lumR - lumL) * 0.5;
      const gy = (lumD - lumU) * 0.5;

      // velocity perpendicular to gradient -> swirl
      const vx =  gy * adv;
      const vy = -gx * adv;

      // backtrace (nearest sampling): compute approximate source cell (float coords)
      // compute current cell coords:
      const cy = (cell / W) | 0;
      const cx = cell - cy * W;
      const srcBase = nearestSampleBase(cx - vx, cy - vy);

      // read advected color (nearest)
      const advR = A[srcBase];
      const advG = A[srcBase + 1];
      const advB = A[srcBase + 2];

      // combine advected + diffusion average
      let newR = advR * (1 - diff) + avgR * diff;
      let newG = advG * (1 - diff) + avgG * diff;
      let newB = advB * (1 - diff) + avgB * diff;

      // apply damping
      newR *= (1 - damp);
      newG *= (1 - damp);
      newB *= (1 - damp);

      // clamp to safe range
      const baseOut = cell * 3;
      B[baseOut]   = newR < -1 ? -1 : (newR > 1.6 ? 1.6 : newR);
      B[baseOut+1] = newG < -1 ? -1 : (newG > 1.6 ? 1.6 : newG);
      B[baseOut+2] = newB < -1 ? -1 : (newB > 1.6 ? 1.6 : newB);
    }

    // swap
    const tmp = simA; simA = simB; simB = tmp;
  }

  // Inject a soft pulse into simA at float grid coords
function exciteAt(gridX, gridY, radius, strength = 1){
  const r2 = radius * radius;
  const x0 = Math.max(0, Math.floor(gridX - radius));
  const x1 = Math.min(W - 1, Math.floor(gridX + radius));
  const y0 = Math.max(0, Math.floor(gridY - radius));
  const y1 = Math.min(H - 1, Math.floor(gridY + radius));

  // pick a base hue for this pulse (warmish range, 0 = red, 0.08~0.12 = whites/oranges)
  let baseHue = Math.random() * 0.15 + 0.05; 

  for (let y = y0; y <= y1; y++){
    for (let x = x0; x <= x1; x++){
      const dx = x - gridX, dy = y - gridY;
      const d2 = dx*dx + dy*dy;
      if (d2 <= r2){
        const f = 1 - Math.sqrt(d2) / radius;
        const i = (y * W + x) * 3;

        // small per-cell hue variation
        let h = (baseHue + (Math.random()-0.5)*0.05) % 1;

        // optional: slowly drift hue based on time or global frame
        h += performance.now() * 0.0002; // tiny drift
        h %= 1;

        // HSL to RGB
        const s = 0.8; // saturation
        const l = 0.5; // lightness
        const rgb = hslToRgb(h, s, l);

        simA[i]   += rgb[0] * strength * f;
        simA[i+1] += rgb[1] * strength * f;
        simA[i+2] += rgb[2] * strength * f;
      }
    }
  }
}

// HSL -> RGB conversion
function hslToRgb(h, s, l){
  let r, g, b;

  if(s == 0){
    r = g = b = l; // achromatic
  } else {
    const hue2rgb = (p, q, t) => {
      if(t < 0) t += 1;
      if(t > 1) t -= 1;
      if(t < 1/6) return p + (q - p) * 6 * t;
      if(t < 1/2) return q;
      if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    }
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }

  return [r, g, b];
}



  // Random excitation accumulator
  function maybeExcite(dt){
    const pulses = excitationRate * dt * 0.001;
    accumExc += pulses;
    while (accumExc >= 1){
      accumExc -= 1;
      const x = Math.random() * W;
      const y = Math.random() * H;
      const rad = Math.random() * 10 + 4;
      const strength = Math.random() * 1.1 + 0.4;
      exciteAt(x,y,rad,strength);
    }
  }

  // Render simA (Float32) -> imageData (Uint8ClampedArray) quickly
function renderToOff(){
  const A = simA;
  const data = imageData.data;

  // first frame: allocate and zero
  if (!accumImage || accumImage.length !== data.length){
    accumImage = new Float32Array(data.length);
    for (let i=0;i<data.length;i++) accumImage[i] = 0;
  }

  const boost = 230;
  const fade = fadeStrength;

  for (let cell = 0, p = 0; cell < size; cell++, p += 4){
    const base = cell * 3;
    let r = A[base]   * 0.8 + 0.03;
    let g = A[base+1] * 0.8 + 0.02;
    let b = A[base+2] * 0.8 + 0.01;

    // minimal cross mix for richer colors
    const cr = r*1.0 + g*0.12 - b*0.05;
    const cg = -0.05*r + g*1.0 + b*0.08;
    const cb = 0.02*r + 0.08*g + b*1.0;

    // tone clamp
    const rr = Math.max(0, Math.min(1.4, cr));
    const gg = Math.max(0, Math.min(1.4, cg));
    const bb = Math.max(0, Math.min(1.4, cb));

    // blend with previous accumulation
    const oldR = accumImage[p];
    const oldG = accumImage[p+1];
    const oldB = accumImage[p+2];

    const newR = oldR*(1-fade) + rr*fade;
    const newG = oldG*(1-fade) + gg*fade;
    const newB = oldB*(1-fade) + bb*fade;

    accumImage[p]   = newR;
    accumImage[p+1] = newG;
    accumImage[p+2] = newB;

    data[p  ] = (newR * boost) | 0;
    data[p+1] = (newG * boost) | 0;
    data[p+2] = (newB * boost) | 0;
    data[p+3] = 255;
  }

  offCtx.putImageData(imageData, 0, 0);
}


  // Upscale offscreen to main canvas
  function drawToScreen(){
    ctx.imageSmoothingEnabled = true;
    ctx.drawImage(off, 0, 0, canvas.width, canvas.height);
  }

  // Seed random noise into simA
  function seedRandom(str=1.0){
    for (let i=0, n=size*3; i<n; i+=3){
      simA[i  ] = (Math.random()-0.5) * str;
      simA[i+1] = (Math.random()-0.5) * str;
      simA[i+2] = (Math.random()-0.5) * str;
    }
  }

  function clearAll(){
    simA.fill(0);
    simB.fill(0);
  }
function makeSpiralPath(cx, cy, radius, turns, points) {
  const path = [];
  for (let i=0; i<points; i++) {
    const t = i / points;
    const angle = t * turns * 2*Math.PI;
    const r = t * radius;
    const x = cx + r * Math.cos(angle);
    const y = cy + r * Math.sin(angle);
    path.push([x, y]);
  }
  return path;
}
// --- Example wave path function ---
function makeWavePath(cx, cy, radius, freq, steps){
const path = [];
  for (let i=0; i<steps; i++) {
    const angle = (i / steps) * Math.PI*2;
    const r = radius * (0.5 + 0.5*Math.sin(angle*freq));
    const x = cx + r * Math.cos(angle*3.1);
    const y = cy + r * Math.sin(angle*2.7);
    path.push([x, y]);
  }
  return path;
}

function simulatePath(path) {
  for (let i=0; i<path.length; i++) {
    const [x,y] = path[i];
    const radius = Math.random() * 6 + 4;
    const strength = Math.random() * 1.2 + 0.3;
    exciteAt(x, y, radius, strength);
  }
}
let t1 = 0;
const spiralPath = makeSpiralPath(W/2, H/2, Math.min(W,H)/3, 3, 200);
// --- New brush ---
let t2 = 0;
const wavePath = makeWavePath(W/2, H/2, Math.min(W,H)/3, 0.05, 200);

function autoPaint() {
  if (t1 >= spiralPath.length) t1 = 0;
  simulatePath([spiralPath[t1]]);
  t1++;
  if (t2 >= wavePath.length) t2 = 0;
  simulatePath([wavePath[t2]]);
  t2++;
}


  // UI wiring
  btnPause.addEventListener('click', ()=>{
    running = !running;
    btnPause.textContent = running ? 'Pause' : 'Resume';
    if (running) { lastFrame = performance.now(); requestAnimationFrame(loop); }
  });
  btnSeed.addEventListener('click', ()=> seedRandom(1.2));
  btnClear.addEventListener('click', ()=> clearAll());
  applyGridBtn.addEventListener('click', ()=>{
    const newW = parseInt(gridWIn.value,10) || W;
    const newH = parseInt(gridHIn.value,10) || H;
    W = clamp(newW, 40, 960);
    H = clamp(newH, 24, 540);
    alloc();
    resizeCanvas();
  });

  diffRange.addEventListener('input', ()=> { diffusion = parseFloat(diffRange.value)/100; diffVal.textContent = diffusion.toFixed(3); });
  advRange.addEventListener('input', ()=> { advection = parseFloat(advRange.value)/100; advVal.textContent = advection.toFixed(3); });
  dampRange.addEventListener('input', ()=> { damping = parseFloat(dampRange.value)/1000; dampVal.textContent = damping.toFixed(4); });
  excRange.addEventListener('input', ()=> { excitationRate = parseFloat(excRange.value); excVal.textContent = excitationRate.toFixed(1); });

  // pointer painting
  let painting = false;
  function pointerToGrid(clientX, clientY){
    const r = canvas.getBoundingClientRect();
    const gx = (clientX - r.left) / r.width * W;
    const gy = (clientY - r.top)  / r.height * H;
    return [gx, gy];
  }
  canvas.addEventListener('mousedown', e => { painting = true; const [gx,gy] = pointerToGrid(e.clientX, e.clientY); exciteAt(gx, gy, Math.max(W/32,6), 1.5); });
  window.addEventListener('mouseup', ()=> painting = false);
  window.addEventListener('mousemove', e => { if(!painting) return; const [gx,gy] = pointerToGrid(e.clientX, e.clientY); exciteAt(gx, gy, Math.max(W/48,4), 0.9); });
  canvas.addEventListener('touchstart', e => { e.preventDefault(); painting = true; const t = e.touches[0]; const [gx,gy] = pointerToGrid(t.clientX, t.clientY); exciteAt(gx, gy, Math.max(W/32,6), 1.8); }, {passive:false});
  canvas.addEventListener('touchmove', e => { e.preventDefault(); if(!painting) return; const t = e.touches[0]; const [gx,gy] = pointerToGrid(t.clientX, t.clientY); exciteAt(gx, gy, Math.max(W/48,4), 1.0); }, {passive:false});
  canvas.addEventListener('touchend', e => { painting = false; }, {passive:false});

  // top-level loop
  function loop(now){
    if (!running) return;
    const dt = Math.max(1, now - lastFrame);
    lastFrame = now;

    // perform 1..2 simulation substeps for stability
    const steps = (W*H > 200000) ? 2 : 1;
    for (let s=0; s<steps; s++) step();

    maybeExcite(dt); 
    autoPaint(); // makes the trails appear automatically


    renderToOff();
    drawToScreen();

    // fps tracking
    frameCount++;
    const tNow = performance.now();
    if (tNow - fpsTime >= 500){
      const fps = Math.round(frameCount / ((tNow - fpsTime)/1000));
      fpsLabel.textContent = fps + ' fps';
      fpsTime = tNow;
      frameCount = 0;
    }

    requestAnimationFrame(loop);
  }

  // init
  function init(){
    resizeCanvas();
    alloc();
    seedRandom(1.0);
    diffVal.textContent = diffusion.toFixed(3);
    advVal.textContent = advection.toFixed(3);
    dampVal.textContent = damping.toFixed(4);
    excVal.textContent = excitationRate.toFixed(1);
    requestAnimationFrame(loop);
  }
  window.addEventListener('resize', resizeCanvas);
  init();

  // expose for tinkering
  window.Dreamflow = { exciteAt, seedRandom, clearAll, getParams:()=>({W,H,diffusion,advection,damping,excitationRate}) };

})();
</script>
</body>
</html>
