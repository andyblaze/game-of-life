<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Dreamflow — CPU optimized</title>
<style>
  html,body{height:100%;margin:0;background:#050507;color:#eaf2ff;font-family:system-ui,Segoe UI,Roboto,Arial;}
  #ui{position:fixed;left:12px;top:12px;background:rgba(3,6,9,0.6);padding:10px;border-radius:10px;z-index:20;width:320px;}
  label{display:block;margin-top:6px;font-size:13px}
  input[type=range]{width:100%}
  button{margin-top:8px;margin-right:6px}
  .row{display:flex;gap:6px;align-items:center}
  .val{min-width:56px;text-align:right;font-family:monospace}
  canvas{display:block;width:100%;height:100vh}
</style>
</head>
<body>
<div id="ui">
  <strong>Dreamflow — CPU optimized</strong>
  <div class="row" style="margin-top:6px">
    <button id="btnPause">Pause</button>
    <button id="btnSeed">Seed</button>
    <button id="btnClear">Clear</button>
    <div style="flex:1"></div>
    <div class="val" id="fps">— fps</div>
  </div>

  <label>Grid (W × H)</label>
  <div class="row">
    <input id="gridW" type="number" min="80" max="960" value="480" style="width:92px">
    <input id="gridH" type="number" min="48" max="540" value="270" style="width:92px">
    <button id="applyGrid">Apply</button>
  </div>

  <label>Diffusion <span class="val" id="diffVal">0.26</span></label>
  <input id="diff" type="range" min="0" max="100" value="26">

  <label>Advection <span class="val" id="advVal">0.40</span></label>
  <input id="adv" type="range" min="0" max="200" value="40">

  <label>Damping <span class="val" id="dampVal">0.008</span></label>
  <input id="damp" type="range" min="0" max="50" value="8">

  <label>Excite/sec <span class="val" id="excVal">8</span></label>
  <input id="exc" type="range" min="0" max="60" value="8">

  <small style="display:block;margin-top:6px">Nearest-neighbor advection is used for speed. Click & drag to paint.</small>
</div>

<canvas id="main"></canvas>

<script>
(() => {
  // DOM
  const canvas = document.getElementById('main');
  const ctx = canvas.getContext('2d', { alpha: false });

  // UI
  const btnPause = document.getElementById('btnPause');
  const btnSeed  = document.getElementById('btnSeed');
  const btnClear = document.getElementById('btnClear');
  const gridWIn = document.getElementById('gridW');
  const gridHIn = document.getElementById('gridH');
  const applyGridBtn = document.getElementById('applyGrid');
  const diffRange = document.getElementById('diff');
  const advRange = document.getElementById('adv');
  const dampRange = document.getElementById('damp');
  const excRange = document.getElementById('exc');
  const diffVal = document.getElementById('diffVal');
  const advVal = document.getElementById('advVal');
  const dampVal = document.getElementById('dampVal');
  const excVal = document.getElementById('excVal');
  const fpsLabel = document.getElementById('fps');
const fadeVal = document.createElement("span");
fadeVal.textContent = "0.90";
const fadeLabel = document.createElement("label");
fadeLabel.textContent = "Fade ";
fadeLabel.appendChild(fadeVal);
const fadeRange = document.createElement("input");
fadeRange.type = "range";
fadeRange.min = "70"; fadeRange.max = "99"; fadeRange.value = "90";
fadeRange.style.width = "100%";
fadeRange.addEventListener("input",()=>{
  fadeStrength = parseFloat(fadeRange.value)/100;
  fadeVal.textContent = fadeStrength.toFixed(2);
});
document.getElementById("ui").appendChild(fadeLabel);
document.getElementById("ui").appendChild(fadeRange);

// Simulation parameters (start values)
const config = {  
  W: parseInt(gridWIn.value,10), 
  H: parseInt(gridHIn.value,10),
  diffusion: parseFloat(diffRange.value)/100,
  advection: parseFloat(advRange.value)/100,
  damping: parseFloat(dampRange.value)/1000,
  excitationRate: parseFloat(excRange.value)
};

  // Buffers & precomputed indices
  /*let size = 0;                // number of cells
  let simA = null, simB = null;// Float32Array length size*3 (rgb)
  let neighbors3 = null;       // Int32Array length size*9 (neighborIndex*3)
  let hue = null;              // per-cell hue bias
  let imageData = null;        // ImageData for low-res drawing*/
  const off = document.createElement('canvas');
  const offCtx = off.getContext('2d');

  // runtime
  let lastFrame = performance.now();
  let fpsTime = performance.now();
  let frameCount = 0;


let fadeStrength = 0.90; // how much of new frame blends in (0.7=long trails, 0.95=fast fade)


  // small helpers
  const clamp = (v,a,b) => v < a ? a : (v > b ? b : v);
// HSL -> RGB conversion
function hslToRgb(h, s, l){
  let r, g, b;

  if(s == 0){
    r = g = b = l; // achromatic
  } else {
    const hue2rgb = (p, q, t) => {
      if(t < 0) t += 1;
      if(t > 1) t -= 1;
      if(t < 1/6) return p + (q - p) * 6 * t;
      if(t < 1/2) return q;
      if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    }
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }

  return [r, g, b];
}

  // Resize main canvas for DPR
  function resizeCanvas(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width  = Math.round(window.innerWidth * dpr);
    canvas.height = Math.round(window.innerHeight * dpr);
    canvas.style.width  = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    ctx.imageSmoothingEnabled = true;
  }
  
class DreamFlow {
    constructor(es=null) {
        this.excitationStrategy = es;
        // Buffers & precomputed indices
        this.size = 0;                // number of cells
        this.simA = null;
        this.simB = null;  // Float32Arrays length size*3 (rgb)
        this.neighbors3 = null;       // Int32Array length size*9 (neighborIndex*3)
        this.hue = null;              // per-cell hue bias
        this.imageData = null;
        this.accumExc = 0;
        // persistence buffer
        this.accumImage = null;
        this.running = true;
        this.alloc();
        this.seedRandom(1.0);
    }
    precomputeNeighbors() {
        // neighbors order: (xm1,ym1),(x,ym1),(xp1,ym1),(xm1,y),(x,y),(xp1,y),(xm1,yp1),(x,yp1),(xp1,yp1)
        const nPerCell = 9;
        this.neighbors3 = new Int32Array(this.size * nPerCell);
        const W = config.W;
        const H = config.H;
        for ( let y = 0; y < H; y++ ) {
            const ym1 = (y>0) ? y-1 : 0;
            const yp1 = (y < H-1) ? y+1 : H-1;
            for ( let x = 0; x < W; x++ ) {
                const xm1 = (x>0) ? x-1 : 0;
                const xp1 = (x < W-1) ? x+1 : W-1;
                const baseCell = y * W + x;
                const cellIndex = baseCell * nPerCell;
                // fill nine neighbors' base*3
                this.neighbors3[cellIndex + 0] = (ym1 * W + xm1) * 3;
                this.neighbors3[cellIndex + 1] = (ym1 * W + x  ) * 3;
                this.neighbors3[cellIndex + 2] = (ym1 * W + xp1) * 3;
                this.neighbors3[cellIndex + 3] = (y   * W + xm1) * 3;
                this.neighbors3[cellIndex + 4] = (y   * W + x  ) * 3; // center
                this.neighbors3[cellIndex + 5] = (y   * W + xp1) * 3;
                this.neighbors3[cellIndex + 6] = (yp1 * W + xm1) * 3;
                this.neighbors3[cellIndex + 7] = (yp1 * W + x  ) * 3;
                this.neighbors3[cellIndex + 8] = (yp1 * W + xp1) * 3;
            }
        }
    }
    // Allocate arrays for current grid size
    alloc() {
        this.size = config.W * config.H;
        this.simA = new Float32Array(this.size * 3);
        this.simB = new Float32Array(this.size * 3);
        this.hue = new Float32Array(this.size);
        for ( let i = 0; i < this.size; i++ ) 
            this.hue[i] = Math.random();
        this.precomputeNeighbors();
        off.width = config.W;
        off.height = config.H;
        this.imageData = offCtx.createImageData(config.W, config.H);
    }
    seedRandom(str=1.0){
        for ( let i = 0, n = this.size * 3; i < n; i+=3 ) {
            this.simA[i  ] = (Math.random()-0.5) * str;
            this.simA[i+1] = (Math.random()-0.5) * str;
            this.simA[i+2] = (Math.random()-0.5) * str;
        }
    }
    nearestSampleBase(x, y) {
        // clamp to grid
        const ix = (x < 0) ? 0 : (x >= config.W ? config.W-1 : (x|0));
        const iy = (y < 0) ? 0 : (y >= config.H ? config.H-1 : (y|0));
        return (iy * config.W + ix) * 3;
    }
    clearAll() {
        this.simA.fill(0);
        this.simB.fill(0);
    }
    update(dt, offscreen, onscreen) {
        // perform 1..2 simulation substeps for stability
        const steps = (config.W * config.H > 200000) ? 2 : 1;
        for ( let s = 0; s < steps; s++ ) 
            this.step(); 
        //if (this.exciteStrategy) this.exciteStrategy.update(dt, this);
        this.maybeExcite(dt);
        this.draw(offscreen, onscreen);
    }
    // One simulation step (hot loop optimized)
    step() {
        const inv9 = 1/9;
        const A = this.simA, B = this.simB, N3 = this.neighbors3;
        const nPerCell = 9;

        // local copies of params for JIT friendliness
        const diff = config.diffusion;
        const adv = config.advection;
        const damp = config.damping;

        // iterate every cell by index i (cell index)
        // we will compute neighbor base offsets using neighbors3
        for ( let cell = 0, nBase = 0; cell < this.size; cell++, nBase += nPerCell ) {
            // neighbor base addresses (already multiplied by 3)
            // note: N3[nBase + k] is the starting index in A for that neighbor's R component
            const nb0 = N3[nBase + 0], nb1 = N3[nBase + 1], nb2 = N3[nBase + 2],
            nb3 = N3[nBase + 3], nb4 = N3[nBase + 4], nb5 = N3[nBase + 5],
            nb6 = N3[nBase + 6], nb7 = N3[nBase + 7], nb8 = N3[nBase + 8];

            // sum R channel across 9 neighbors
            // reading sequentially from A, which is Float32Array
            const rSum = A[nb0] + A[nb1] + A[nb2] + A[nb3] + A[nb4] + A[nb5] + A[nb6] + A[nb7] + A[nb8];
            const gSum = A[nb0+1] + A[nb1+1] + A[nb2+1] + A[nb3+1] + A[nb4+1] + A[nb5+1] + A[nb6+1] + A[nb7+1] + A[nb8+1];
            const bSum = A[nb0+2] + A[nb1+2] + A[nb2+2] + A[nb3+2] + A[nb4+2] + A[nb5+2] + A[nb6+2] + A[nb7+2] + A[nb8+2];

            // average
            const avgR = rSum * inv9;
            const avgG = gSum * inv9;
            const avgB = bSum * inv9;

            // compute luminance gradient using left/right/up/down neighbors (nearest)
            // left neighbor base = nb3, right = nb5, up = nb1, down = nb7
            const lumC = (A[nb4] + A[nb4+1] + A[nb4+2]) / 3;
            const lumL = (A[nb3] + A[nb3+1] + A[nb3+2]) / 3;
            const lumR = (A[nb5] + A[nb5+1] + A[nb5+2]) / 3;
            const lumU = (A[nb1] + A[nb1+1] + A[nb1+2]) / 3;
            const lumD = (A[nb7] + A[nb7+1] + A[nb7+2]) / 3;

            const gx = (lumR - lumL) * 0.5;
            const gy = (lumD - lumU) * 0.5;

            // velocity perpendicular to gradient -> swirl
            const vx =  gy * adv;
            const vy = -gx * adv;

            // backtrace (nearest sampling): compute approximate source cell (float coords)
            // compute current cell coords:
            const cy = (cell / config.W) | 0;
            const cx = cell - cy * config.W;
            const srcBase = this.nearestSampleBase(cx - vx, cy - vy);

            // read advected color (nearest)
            const advR = A[srcBase];
            const advG = A[srcBase + 1];
            const advB = A[srcBase + 2];

            // combine advected + diffusion average
            let newR = advR * (1 - diff) + avgR * diff;
            let newG = advG * (1 - diff) + avgG * diff;
            let newB = advB * (1 - diff) + avgB * diff;

            // apply damping
            newR *= (1 - damp);
            newG *= (1 - damp);
            newB *= (1 - damp);

            // clamp to safe range
            const baseOut = cell * 3;
            B[baseOut]   = newR < -1 ? -1 : (newR > 1.6 ? 1.6 : newR);
            B[baseOut+1] = newG < -1 ? -1 : (newG > 1.6 ? 1.6 : newG);
            B[baseOut+2] = newB < -1 ? -1 : (newB > 1.6 ? 1.6 : newB);
        }
        // swap
        const tmp = this.simA; this.simA = this.simB; this.simB = tmp;
    }
    draw(offscreen, onscreen) {
        dreamFlow.renderToOff(offscreen);
        dreamFlow.drawToScreen(onscreen);
    }
    // Render simA (Float32) -> imageData (Uint8ClampedArray) quickly
    renderToOff() {
        const A = this.simA;
        const data = this.imageData.data;

        // first frame: allocate and zero
        if ( ! this.accumImage || this.accumImage.length !== data.length ) {
            this.accumImage = new Float32Array(data.length);
            for ( let i = 0; i < data.length; i++ ) 
                this.accumImage[i] = 0;
        }
        const accumImage = this.accumImage;
        const boost = 230;
        const fade = fadeStrength;

        for ( let cell = 0, p = 0; cell < this.size; cell++, p += 4 ) {
            const base = cell * 3;
            let r = A[base]   * 0.8 + 0.03;
            let g = A[base+1] * 0.8 + 0.02;
            let b = A[base+2] * 0.8 + 0.01;

            // minimal cross mix for richer colors
            const cr = r*1.0 + g*0.12 - b*0.05;
            const cg = -0.05*r + g*1.0 + b*0.08;
            const cb = 0.02*r + 0.08*g + b*1.0;

            // tone clamp
            const rr = Math.max(0, Math.min(1.4, cr));
            const gg = Math.max(0, Math.min(1.4, cg));
            const bb = Math.max(0, Math.min(1.4, cb));

            // blend with previous accumulation
            const oldR = accumImage[p];
            const oldG = accumImage[p+1];
            const oldB = accumImage[p+2];

            const newR = oldR*(1-fade) + rr*fade;
            const newG = oldG*(1-fade) + gg*fade;
            const newB = oldB*(1-fade) + bb*fade;

            accumImage[p]   = newR;
            accumImage[p+1] = newG;
            accumImage[p+2] = newB;

            data[p  ] = (newR * boost) | 0;
            data[p+1] = (newG * boost) | 0;
            data[p+2] = (newB * boost) | 0;
            data[p+3] = 255;
        }
        offCtx.putImageData(this.imageData, 0, 0);
    }
    drawToScreen(ctx) {
        ctx.imageSmoothingEnabled = true;
        ctx.drawImage(off, 0, 0, canvas.width, canvas.height);
    }
    // Random excitation accumulator
    maybeExcite(dt) {
        const pulses = config.excitationRate * dt * 0.001;
        this.accumExc += pulses;
        while ( this.accumExc >= 1 ) {
            this.accumExc -= 1;
            const x = Math.random() * config.W;
            const y = Math.random() * config.H;
            const rad = Math.random() * 10 + 4;
            const strength = Math.random() * 1.1 + 0.4;
            this.exciteAt(x, y, rad, strength);
        }
    }
    // Inject a soft pulse into simA at float grid coords
    exciteAt(gridX, gridY, radius, strength = 1) {
        const r2 = radius * radius;
        const x0 = Math.max(0, Math.floor(gridX - radius));
        const x1 = Math.min(config.W - 1, Math.floor(gridX + radius));
        const y0 = Math.max(0, Math.floor(gridY - radius));
        const y1 = Math.min(config.H - 1, Math.floor(gridY + radius));

        // pick a base hue for this pulse (warmish range, 0 = red, 0.08~0.12 = whites/oranges)
        let baseHue = Math.random() * 0.15 + 0.05; 

        for ( let y = y0; y <= y1; y++ ) {
            for ( let x = x0; x <= x1; x++ ) {
                const dx = x - gridX, dy = y - gridY;
                const d2 = dx*dx + dy*dy;
                if ( d2 <= r2 ) {
                    const f = 1 - Math.sqrt(d2) / radius;
                    const i = (y * config.W + x) * 3;

                    // small per-cell hue variation
                    let h = (baseHue + (Math.random() - 0.5 ) * 0.05) % 1;

                    // optional: slowly drift hue based on time or global frame
                    h += performance.now() * 0.0002; // tiny drift
                    h %= 1;

                    // HSL to RGB
                    const s = 0.8; // saturation
                    const l = 0.5; // lightness
                    const rgb = hslToRgb(h, s, l);

                    this.simA[i]   += rgb[0] * strength * f;
                    this.simA[i+1] += rgb[1] * strength * f;
                    this.simA[i+2] += rgb[2] * strength * f;
                }
            }
        }
    }    
}

class ExcitationStrategy {
    update(dt, dreamflow) {} // called every frame
}

class RandomExcite extends ExcitationStrategy {
    constructor() { 
        super(); 
    }
    update(dt, df) {
        this.accum += this.rate * dt * 0.001;
        while (this.accum >= 1) {
            this.accum -= 1;
            const x = Math.random() * df.W;
            const y = Math.random() * df.H;
            df.exciteAt(x, y, Math.random() * 10 + 4, Math.random() * 1.1 + 0.4);
        }
    }
}

const dreamFlow = new DreamFlow(new RandomExcite());

function makeSpiralPath(cx, cy, radius, turns, points) {
  const path = [];
  for (let i=0; i<points; i++) {
    const t = i / points;
    const angle = t * turns * 2*Math.PI;
    const r = t * radius;
    const x = cx + r * Math.cos(angle);
    const y = cy + r * Math.sin(angle);
    path.push([x, y]);
  }
  return path;
}
// --- Example wave path function ---
function makeWavePath(cx, cy, radius, freq, steps){
const path = [];
  for (let i=0; i<steps; i++) {
    const angle = (i / steps) * Math.PI*2;
    const r = radius * (0.5 + 0.5*Math.sin(angle*freq));
    const x = cx + r * Math.cos(angle*3.1);
    const y = cy + r * Math.sin(angle*2.7);
    path.push([x, y]);
  }
  return path;
}

function simulatePath(path) {
  for (let i=0; i<path.length; i++) {
    const [x,y] = path[i];
    const radius = Math.random() * 6 + 4;
    const strength = Math.random() * 1.2 + 0.3;
    dreamFlow.exciteAt(x, y, radius, strength);
  }
}
let t1 = 0;
const spiralPath = makeSpiralPath(config.W/2, config.H/2, Math.min(config.W,config.H)/3, 3, 200);
// --- New brush ---
let t2 = 0;
const wavePath = makeWavePath(config.W/2, config.H/2, Math.min(config.W,config.H)/3, 0.05, 200);

function autoPaint() {
  if (t1 >= spiralPath.length) t1 = 0;
  simulatePath([spiralPath[t1]]);
  t1++;
  if (t2 >= wavePath.length) t2 = 0;
  simulatePath([wavePath[t2]]);
  t2++;
}


  // UI wiring
  btnPause.addEventListener('click', ()=>{
    running = !running;
    btnPause.textContent = running ? 'Pause' : 'Resume';
    if (running) { lastFrame = performance.now(); requestAnimationFrame(loop); }
  });
  btnSeed.addEventListener('click', ()=> seedRandom(1.2));
  btnClear.addEventListener('click', ()=> clearAll());
  applyGridBtn.addEventListener('click', ()=>{
    const newW = parseInt(gridWIn.value,10) || config.W;
    const newH = parseInt(gridHIn.value,10) || config.H;
    config.W = clamp(newW, 40, 960);
    config.H = clamp(newH, 24, 540);
    alloc();
    resizeCanvas();
  });

  diffRange.addEventListener('input', ()=> { config.diffusion = parseFloat(diffRange.value)/100; diffVal.textContent = config.diffusion.toFixed(3); });
  advRange.addEventListener('input', ()=> { config.advection = parseFloat(advRange.value)/100; advVal.textContent = config.advection.toFixed(3); });
  dampRange.addEventListener('input', ()=> { config.damping = parseFloat(dampRange.value)/1000; dampVal.textContent = config.damping.toFixed(4); });
  excRange.addEventListener('input', ()=> { config.excitationRate = parseFloat(excRange.value); excVal.textContent = config.excitationRate.toFixed(1); });

  // pointer painting
  let painting = false;
  function pointerToGrid(clientX, clientY){
    const r = canvas.getBoundingClientRect();
    const gx = (clientX - r.left) / r.width * config.W;
    const gy = (clientY - r.top)  / r.height * config.H;
    return [gx, gy];
  }
  canvas.addEventListener('mousedown', e => { painting = true; const [gx,gy] = pointerToGrid(e.clientX, e.clientY); dreamFlow.exciteAt(gx, gy, Math.max(config.W/32,6), 1.5); });
  window.addEventListener('mouseup', ()=> painting = false);
  window.addEventListener('mousemove', e => { if(!painting) return; const [gx,gy] = pointerToGrid(e.clientX, e.clientY); dreamFlow.exciteAt(gx, gy, Math.max(config.W/48,4), 0.9); });
  canvas.addEventListener('touchstart', e => { e.preventDefault(); painting = true; const t = e.touches[0]; const [gx,gy] = pointerToGrid(t.clientX, t.clientY); exciteAt(gx, gy, Math.max(W/32,6), 1.8); }, {passive:false});
  canvas.addEventListener('touchmove', e => { e.preventDefault(); if(!painting) return; const t = e.touches[0]; const [gx,gy] = pointerToGrid(t.clientX, t.clientY); exciteAt(gx, gy, Math.max(W/48,4), 1.0); }, {passive:false});
  canvas.addEventListener('touchend', e => { painting = false; }, {passive:false});

  // top-level loop
  function loop(now) {
    if ( ! dreamFlow.running ) return;
    const dt = Math.max(1, now - lastFrame);
    lastFrame = now;
    dreamFlow.update(dt, offCtx, ctx);
    autoPaint(); // makes the trails appear automatically
    // fps tracking
    frameCount++;
    const tNow = performance.now();
    if (tNow - fpsTime >= 500){
      const fps = Math.round(frameCount / ((tNow - fpsTime)/1000));
      fpsLabel.textContent = fps + ' fps';
      fpsTime = tNow;
      frameCount = 0;
    }
    requestAnimationFrame(loop);
  }

  // init
  function init(){
    resizeCanvas();
    diffVal.textContent = config.diffusion.toFixed(3);
    advVal.textContent = config.advection.toFixed(3);
    dampVal.textContent = config.damping.toFixed(4);
    excVal.textContent = config.excitationRate.toFixed(1);
    requestAnimationFrame(loop);
  }
  window.addEventListener('resize', resizeCanvas);
  init();

  // expose for tinkering
window.Dreamflow = {
  exciteAt: dreamFlow.exciteAt.bind(dreamFlow),
  seedRandom: dreamFlow.seedRandom.bind(dreamFlow),
  clearAll: dreamFlow.clearAll.bind(dreamFlow),
  getParams: () => ({
    W,
    H,
    diffusion,
    advection,
    damping,
    excitationRate
  })
};

})();
</script>
</body>
</html>
