<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Dreamflow — CPU optimized</title>
<style>
  html,body{height:100%;margin:0;background:#050507;color:#eaf2ff;font-family:system-ui,Segoe UI,Roboto,Arial;}
  #ui{position:fixed;left:12px;top:12px;background:rgba(3,6,9,0.6);padding:10px;border-radius:10px;z-index:20;width:320px;}
  label{display:block;margin-top:6px;font-size:13px}
  input[type=range]{width:100%}
  button{margin-top:8px;margin-right:6px}
  .row{display:flex;gap:6px;align-items:center}
  .val{min-width:56px;text-align:right;font-family:monospace}
  canvas{display:block;width:100%;height:100vh}
</style>
</head>
<body>
<div id="ui">
  <strong>Dreamflow — CPU optimized</strong>
  <div class="row" style="margin-top:6px">
    <button id="btnPause">Pause</button>
    <button id="btnSeed">Seed</button>
    <button id="btnClear">Clear</button>
    <div style="flex:1"></div>
    <div class="val" id="fps">— fps</div>
  </div>

  <label>Grid (W × H)</label>
  <div class="row">
    <input id="gridW" type="number" min="80" max="960" value="480" style="width:92px">
    <input id="gridH" type="number" min="48" max="540" value="270" style="width:92px">
    <button id="applyGrid">Apply</button>
  </div>

  <label>Diffusion <span class="val" id="diffVal">0.26</span></label>
  <input id="diff" type="range" min="0" max="100" value="26">

  <label>Advection <span class="val" id="advVal">0.40</span></label>
  <input id="adv" type="range" min="0" max="200" value="40">

  <label>Damping <span class="val" id="dampVal">0.008</span></label>
  <input id="damp" type="range" min="0" max="50" value="8">

  <label>Excite/sec <span class="val" id="excVal">8</span></label>
  <input id="exc" type="range" min="0" max="60" value="8">

  <label>Fade <span class="val" id="fadeVal">0.90</span></label>
  <input id="fade" type="range" min="70" max="90" value="90">

  <small style="display:block;margin-top:6px">Nearest-neighbor advection is used for speed. Click & drag to paint.</small>
</div>

<canvas id="main"></canvas>

<script>
(() => {
  // DOM
const canvas = document.getElementById('main');
const ctx = canvas.getContext('2d', { alpha: false });

  // UI
  const btnPause = document.getElementById('btnPause');
  const btnSeed  = document.getElementById('btnSeed');
  const btnClear = document.getElementById('btnClear');
  const gridWIn = document.getElementById('gridW');
  const gridHIn = document.getElementById('gridH');
  const applyGridBtn = document.getElementById('applyGrid');
  const diffRange = document.getElementById('diff');
  const advRange = document.getElementById('adv');
  const dampRange = document.getElementById('damp');
  const excRange = document.getElementById('exc');
  const fadeRange = document.getElementById('fade');
  const diffVal = document.getElementById('diffVal');
  const advVal = document.getElementById('advVal');
  const dampVal = document.getElementById('dampVal');
  const excVal = document.getElementById('excVal');
  const fadeVal = document.getElementById('fadeVal');
  const fpsLabel = document.getElementById('fps');

// Simulation parameters (start values)
const config = {  
  W: parseInt(gridWIn.value,10), 
  H: parseInt(gridHIn.value,10),
  diffusion: parseFloat(diffRange.value)/100,
  advection: parseFloat(advRange.value)/100,
  damping: parseFloat(dampRange.value)/1000,
  excitationRate: parseFloat(excRange.value),
  fadeStrength: parseFloat(fadeRange.value)/100
};

const off = document.createElement('canvas');
const offCtx = off.getContext('2d');

const clamp = (v,a,b) => v < a ? a : (v > b ? b : v);

function hslToRgb(h, s, l){
  let r, g, b;

  if(s == 0){
    r = g = b = l; // achromatic
  } else {
    const hue2rgb = (p, q, t) => {
      if(t < 0) t += 1;
      if(t > 1) t -= 1;
      if(t < 1/6) return p + (q - p) * 6 * t;
      if(t < 1/2) return q;
      if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    }
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }

  return [r, g, b];
}


function resizeCanvas() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width  = Math.round(window.innerWidth * dpr);
    canvas.height = Math.round(window.innerHeight * dpr);
    canvas.style.width  = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    ctx.imageSmoothingEnabled = true;
}
  
class DreamFlow {
    constructor(config, es=null) {
        this.cfg = config;
        // base values from config (slider-controlled)
        this.baseDiffusion = config.diffusion;
        this.baseAdvection = config.advection;
        this.baseDamping = config.damping;
        this.baseFade = config.fadeStrength;

        // current values used in simulation
        this.diffusion = this.baseDiffusion;
        this.advection = this.baseAdvection;
        this.damping = this.baseDamping;
        this.fadeStrength = this.baseFade;
        this.time = 0;
        this.exciteStrategy = es;
        // Buffers & precomputed indices
        this.size = 0;                // number of cells
        this.simA = null;
        this.simB = null;  // Float32Arrays length size*3 (rgb)
        this.neighbors3 = null;       // Int32Array length size*9 (neighborIndex*3)
        this.hue = null;              // per-cell hue bias
        this.imageData = null;
        this.accumExc = 0;
        // persistence buffer
        this.accumImage = null;
        this.running = true;
        this.alloc(config);
        this.seedRandom(1.0);
        this.brushes = [];
        this.scheduler = null;
    }
    precomputeNeighbors(config) {
        // neighbors order: (xm1,ym1),(x,ym1),(xp1,ym1),(xm1,y),(x,y),(xp1,y),(xm1,yp1),(x,yp1),(xp1,yp1)
        const nPerCell = 9;
        this.neighbors3 = new Int32Array(this.size * nPerCell);
        const W = config.W;
        const H = config.H;
        for ( let y = 0; y < H; y++ ) {
            const ym1 = (y>0) ? y-1 : 0;
            const yp1 = (y < H-1) ? y+1 : H-1;
            for ( let x = 0; x < W; x++ ) {
                const xm1 = (x>0) ? x-1 : 0;
                const xp1 = (x < W-1) ? x+1 : W-1;
                const baseCell = y * W + x;
                const cellIndex = baseCell * nPerCell;
                // fill nine neighbors' base*3
                this.neighbors3[cellIndex + 0] = (ym1 * W + xm1) * 3;
                this.neighbors3[cellIndex + 1] = (ym1 * W + x  ) * 3;
                this.neighbors3[cellIndex + 2] = (ym1 * W + xp1) * 3;
                this.neighbors3[cellIndex + 3] = (y   * W + xm1) * 3;
                this.neighbors3[cellIndex + 4] = (y   * W + x  ) * 3; // center
                this.neighbors3[cellIndex + 5] = (y   * W + xp1) * 3;
                this.neighbors3[cellIndex + 6] = (yp1 * W + xm1) * 3;
                this.neighbors3[cellIndex + 7] = (yp1 * W + x  ) * 3;
                this.neighbors3[cellIndex + 8] = (yp1 * W + xp1) * 3;
            }
        }
    }
    // Allocate arrays for current grid size
    alloc(config) {
        this.size = config.W * config.H;
        this.simA = new Float32Array(this.size * 3);
        this.simB = new Float32Array(this.size * 3);
        this.hue = new Float32Array(this.size);
        for ( let i = 0; i < this.size; i++ ) 
            this.hue[i] = Math.random();
        this.precomputeNeighbors(config);
        off.width = config.W;
        off.height = config.H;
        this.imageData = offCtx.createImageData(config.W, config.H);
    }
    seedRandom(str=1.0){
        for ( let i = 0, n = this.size * 3; i < n; i+=3 ) {
            this.simA[i  ] = (Math.random()-0.5) * str;
            this.simA[i+1] = (Math.random()-0.5) * str;
            this.simA[i+2] = (Math.random()-0.5) * str;
        }
    }
    nearestSampleBase(config, x, y) {
        // clamp to grid
        const ix = (x < 0) ? 0 : (x >= config.W ? config.W-1 : (x|0));
        const iy = (y < 0) ? 0 : (y >= config.H ? config.H-1 : (y|0));
        return (iy * config.W + ix) * 3;
    }
    clearAll() {
        this.simA.fill(0);
        this.simB.fill(0);
    }
    update(dt, offscreen, onscreen) {
        this.updateParams(dt);
        // perform 1..2 simulation substeps for stability
        const steps = (config.W * config.H > 200000) ? 2 : 1;
        for ( let s = 0; s < steps; s++ ) 
            this.step(this.cfg); 
        if ( this.exciteStrategy ) {
            this.exciteStrategy.update(dt, this);
        }
        this.autoDraw(dt);
        this.draw(offscreen, onscreen);
    }
    updateParams(dt) {
        this.time += dt;
        const drift = t => 0.5 + 0.5 * Math.sin(t);

        // base drift speed – very slow overall
        const base = 0.00005;  // smaller = slower drift

        // use different primes for each parameter
        const f1 = 2 * base;   // 2 × base
        const f2 = 3 * base;   // 3 × base
        const f3 = 5 * base;   // 5 × base
        const f4 = 7 * base;   // 7 × base

        this.diffusion    = drift(this.time * f1 + 0.3);             // 0 → 1
        this.advection    = drift(this.time * f2 + 1.1) * 2.0;       // 0 → 2
        this.damping      = drift(this.time * f3 + 2.7) * 0.02;      // 0 → 0.02
        this.fadeStrength = 0.7 + 0.29 * drift(this.time * f4 + 3.5);// 0.7 → 0.99

        // clamp for safety
        this.diffusion    = Math.max(0, Math.min(1, this.diffusion));
        this.advection    = Math.max(0, Math.min(2, this.advection));
        this.damping      = Math.max(0, Math.min(0.02, this.damping));
        this.fadeStrength = Math.max(0.7, Math.min(0.99, this.fadeStrength));
    }
    autoDraw(dt) {
        /*for ( const b of this.brushes )
            b.update(this);*/
        this.scheduler.update(dt, this);
    }
    // One simulation step (hot loop optimized)
    step(config) {
        const inv9 = 1/9;
        const A = this.simA, B = this.simB, N3 = this.neighbors3;
        const nPerCell = 9;

        // local copies of params for JIT friendliness
        const diff = this.diffusion;
        const adv = this.advection;
        const damp = this.damping;

        // iterate every cell by index i (cell index)
        // we will compute neighbor base offsets using neighbors3
        for ( let cell = 0, nBase = 0; cell < this.size; cell++, nBase += nPerCell ) {
            // neighbor base addresses (already multiplied by 3)
            // note: N3[nBase + k] is the starting index in A for that neighbor's R component
            const nb0 = N3[nBase + 0], nb1 = N3[nBase + 1], nb2 = N3[nBase + 2],
            nb3 = N3[nBase + 3], nb4 = N3[nBase + 4], nb5 = N3[nBase + 5],
            nb6 = N3[nBase + 6], nb7 = N3[nBase + 7], nb8 = N3[nBase + 8];

            // sum R channel across 9 neighbors
            // reading sequentially from A, which is Float32Array
            const rSum = A[nb0] + A[nb1] + A[nb2] + A[nb3] + A[nb4] + A[nb5] + A[nb6] + A[nb7] + A[nb8];
            const gSum = A[nb0+1] + A[nb1+1] + A[nb2+1] + A[nb3+1] + A[nb4+1] + A[nb5+1] + A[nb6+1] + A[nb7+1] + A[nb8+1];
            const bSum = A[nb0+2] + A[nb1+2] + A[nb2+2] + A[nb3+2] + A[nb4+2] + A[nb5+2] + A[nb6+2] + A[nb7+2] + A[nb8+2];

            // average
            const avgR = rSum * inv9;
            const avgG = gSum * inv9;
            const avgB = bSum * inv9;

            // compute luminance gradient using left/right/up/down neighbors (nearest)
            // left neighbor base = nb3, right = nb5, up = nb1, down = nb7
            const lumC = (A[nb4] + A[nb4+1] + A[nb4+2]) / 3;
            const lumL = (A[nb3] + A[nb3+1] + A[nb3+2]) / 3;
            const lumR = (A[nb5] + A[nb5+1] + A[nb5+2]) / 3;
            const lumU = (A[nb1] + A[nb1+1] + A[nb1+2]) / 3;
            const lumD = (A[nb7] + A[nb7+1] + A[nb7+2]) / 3;

            const gx = (lumR - lumL) * 0.5;
            const gy = (lumD - lumU) * 0.5;

            // velocity perpendicular to gradient -> swirl
            const vx =  gy * adv;
            const vy = -gx * adv;

            // backtrace (nearest sampling): compute approximate source cell (float coords)
            // compute current cell coords:
            const cy = (cell / config.W) | 0;
            const cx = cell - cy * config.W;
            const srcBase = this.nearestSampleBase(config, cx - vx, cy - vy);

            // read advected color (nearest)
            const advR = A[srcBase];
            const advG = A[srcBase + 1];
            const advB = A[srcBase + 2];

            // combine advected + diffusion average
            let newR = advR * (1 - diff) + avgR * diff;
            let newG = advG * (1 - diff) + avgG * diff;
            let newB = advB * (1 - diff) + avgB * diff;

            // apply damping
            newR *= (1 - damp);
            newG *= (1 - damp);
            newB *= (1 - damp);

            // clamp to safe range
            const baseOut = cell * 3;
            B[baseOut]   = newR < -1 ? -1 : (newR > 1.6 ? 1.6 : newR);
            B[baseOut+1] = newG < -1 ? -1 : (newG > 1.6 ? 1.6 : newG);
            B[baseOut+2] = newB < -1 ? -1 : (newB > 1.6 ? 1.6 : newB);
        }
        // swap
        const tmp = this.simA; this.simA = this.simB; this.simB = tmp;
    }
    draw(offscreen, onscreen) {
        dreamFlow.renderToOff(offscreen);
        dreamFlow.drawToScreen(onscreen);
    }
    // Render simA (Float32) -> imageData (Uint8ClampedArray) quickly
    renderToOff(offscreen) {
        const A = this.simA;
        const data = this.imageData.data;

        // first frame: allocate and zero
        if ( ! this.accumImage || this.accumImage.length !== data.length ) {
            this.accumImage = new Float32Array(data.length);
            for ( let i = 0; i < data.length; i++ ) 
                this.accumImage[i] = 0;
        }
        const accumImage = this.accumImage;
        const boost = 230;
        const fade = this.fadeStrength;

        for ( let cell = 0, p = 0; cell < this.size; cell++, p += 4 ) {
            const base = cell * 3;
            let r = A[base]   * 0.8 + 0.03;
            let g = A[base+1] * 0.8 + 0.02;
            let b = A[base+2] * 0.8 + 0.01;

            // minimal cross mix for richer colors
            const cr = r*1.0 + g*0.12 - b*0.05;
            const cg = -0.05*r + g*1.0 + b*0.08;
            const cb = 0.02*r + 0.08*g + b*1.0;

            // tone clamp
            const rr = Math.max(0, Math.min(1.4, cr));
            const gg = Math.max(0, Math.min(1.4, cg));
            const bb = Math.max(0, Math.min(1.4, cb));

            // blend with previous accumulation
            const oldR = accumImage[p];
            const oldG = accumImage[p+1];
            const oldB = accumImage[p+2];

            const newR = oldR*(1-fade) + rr*fade;
            const newG = oldG*(1-fade) + gg*fade;
            const newB = oldB*(1-fade) + bb*fade;

            accumImage[p]   = newR;
            accumImage[p+1] = newG;
            accumImage[p+2] = newB;

            data[p  ] = (newR * boost) | 0;
            data[p+1] = (newG * boost) | 0;
            data[p+2] = (newB * boost) | 0;
            data[p+3] = 255;
        }
        offscreen.putImageData(this.imageData, 0, 0);
    }
    drawToScreen(onscreen) {
        onscreen.imageSmoothingEnabled = true;
        onscreen.drawImage(off, 0, 0, canvas.width, canvas.height);
    }
    // Inject a soft pulse into simA at float grid coords
    exciteAt(gridX, gridY, radius, strength = 1) {
        const r2 = radius * radius;
        const x0 = Math.max(0, Math.floor(gridX - radius));
        const x1 = Math.min(this.cfg.W - 1, Math.floor(gridX + radius));
        const y0 = Math.max(0, Math.floor(gridY - radius));
        const y1 = Math.min(this.cfg.H - 1, Math.floor(gridY + radius));

        // pick a base hue for this pulse (warmish range, 0 = red, 0.08~0.12 = whites/oranges)
        let baseHue = Math.random() * 0.15 + 0.05; 

        for ( let y = y0; y <= y1; y++ ) {
            for ( let x = x0; x <= x1; x++ ) {
                const dx = x - gridX, dy = y - gridY;
                const d2 = dx*dx + dy*dy;
                if ( d2 <= r2 ) {
                    const f = 1 - Math.sqrt(d2) / radius;
                    const i = (y * this.cfg.W + x) * 3;

                    // small per-cell hue variation
                    let h = (baseHue + (Math.random() - 0.5 ) * 0.05) % 1;

                    // optional: slowly drift hue based on time or global frame
                    h += performance.now() * 0.0002; // tiny drift
                    h %= 1;

                    // HSL to RGB
                    const s = 0.8; // saturation
                    const l = 0.5; // lightness
                    const rgb = hslToRgb(h, s, l);

                    this.simA[i]   += rgb[0] * strength * f;
                    this.simA[i+1] += rgb[1] * strength * f;
                    this.simA[i+2] += rgb[2] * strength * f;
                }
            }
        }
    }  
    addBrush(b) {
        this.brushes.push(b);
    }
    addScheduler(s) {
        this.scheduler = s;
    }
}

class ExcitationStrategy {
    update(dt, df) {} // called every frame
}

class RandomExcite extends ExcitationStrategy {
    constructor(config) { 
        super(); 
        this.cfg = config;
        this.accumExc = 0;
    }
    update(dt, df) { 
        const pulses = this.cfg.excitationRate * dt * 0.001;
        this.accumExc += pulses;
        while (this.accumExc >= 1) {
            this.accumExc -= 1;
            const x = Math.random() * this.cfg.W;
            const y = Math.random() * this.cfg.H;
            df.exciteAt(x, y, Math.random() * 10 + 4, Math.random() * 1.1 + 0.4);
        }
    }
}

const dreamFlow = new DreamFlow(config, new RandomExcite(config));
function wavePath(cx, cy, radius, freq, steps) {
    const path = [];
    for (let i=0; i<steps; i++) {
        const angle = (i / steps) * Math.PI*2;
        const r = radius * (0.5 + 0.5*Math.sin(angle*freq));
        const x = cx + r * Math.cos(angle*3.1);
        const y = cy + r * Math.sin(angle*2.7);
        path.push([x, y]);
    }
    return path;
}

function spiralPath(cx, cy, radius, turns, points) {
    const path = [];
    for (let i=0; i<points; i++) {
        const t = i / points;
        const angle = t * turns * 2*Math.PI;
        const r = t * radius;
        const x = cx + r * Math.cos(angle);
        const y = cy + r * Math.sin(angle);
        path.push([x, y]);
    }
    return path;
}

class BaseBrush {
    constructor(lifetime) {
        this.t = 0;
        this.age = 0;
        this.lifetime = lifetime;
    }
    expired() {
        return this.age > this.lifetime;
    }
    updateAge() {
        this.age += 1 / 60;
    }
    reset() {
        this.age = 0;
        this.t = 0;
    }
}

class NullBrush extends BaseBrush {
    constructor() {
        super(Math.floor(Math.random() * 2) + 3);
    }
    update() {
        this.updateAge();
    }
}

class Brush extends BaseBrush {
    constructor(lifetime, p) {
        super(lifetime);
        this.path = p;
    }
    update(dt, df) {
        this.updateAge();
        if ( this.t >= this.path.length )
            this.t = 0;
        this.draw([this.path[this.t]], df);
        this.t++;
    }
    draw(path, df) {
        for ( let i = 0; i < path.length; i++ ) {
            const [x,y] = path[i];
            const radius = Math.random() * 6 + 4;
            const strength = Math.random() * 1.2 + 0.3;
            df.exciteAt(x, y, radius, strength);
        }
    }
}

class BinaryBrush extends BaseBrush {
  constructor(lifetime, cx, cy, distance = 200, m1 = 1, m2 = 1.2, G = 1) {
    super(lifetime);
    this.a = { x: cx - distance/2, y: cy, vx: 0, vy: 0, m: m1 };
    this.b = { x: cx + distance/2, y: cy, vx: 0, vy: 0, m: m2 };
    this.G = G;
    this.initialDistance = distance;
    this.eps = 1;           // gravity softening
    this.damping = 0.9995;    // slight velocity damping
    this.spring = 0.015;      // distance correction strength
    this.orbitTilt = (Math.random() - 0.5) * 0.3; // random plane wobble
  }

  // precompute roughly circular starting velocities
  initOrbit() {
    const dx = this.b.x - this.a.x;
    const dy = this.b.y - this.a.y;
    const r = Math.sqrt(dx*dx + dy*dy);
    const v = Math.sqrt(this.G * (this.a.m + this.b.m) / r);

    // perpendicular direction (unit)
    const nx = -dy / r;
    const ny = dx / r;

    // split velocity according to masses (center of mass stationary)
    this.a.vx =  nx * v * (this.b.m / (this.a.m + this.b.m));
    this.a.vy =  ny * v * (this.b.m / (this.a.m + this.b.m));
    this.b.vx = -nx * v * (this.a.m / (this.a.m + this.b.m));
    this.b.vy = -ny * v * (this.a.m / (this.a.m + this.b.m));
  }

  update(dt, df) {
    this.updateAge();
    const { a, b } = this;

    // vector from a -> b
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    const r2 = dx*dx + dy*dy + this.eps;
    const r = Math.sqrt(r2);

    // gravitational force magnitude
    const F = this.G * a.m * b.m / r2;

    // normalized direction
    const fx = (dx / r) * F;
    const fy = (dy / r) * F;

    // accelerate both
    a.vx += fx / a.m;
    a.vy += fy / a.m;
    b.vx -= fx / b.m;
    b.vy -= fy / b.m;

    // soft spring to maintain approximate separation
    const dr = r - this.initialDistance;
    if (Math.abs(dr) > 0.5) {
      const corr = this.spring * dr;
      a.vx +=  dx / r * corr / 2;
      a.vy +=  dy / r * corr / 2;
      b.vx -=  dx / r * corr / 2;
      b.vy -=  dy / r * corr / 2;
    }

    // update positions
    a.x += a.vx;
    a.y += a.vy + this.orbitTilt;
    b.x += b.vx;
    b.y += b.vy - this.orbitTilt;

    // velocity damping for stability
    a.vx *= this.damping;
    a.vy *= this.damping;
    b.vx *= this.damping;
    b.vy *= this.damping;

    // draw both stars
    this.draw(df, a);
    this.draw(df, b);
  }

  draw(df, body) {
    const radius = 6 + Math.random() * 6;
    const strength = 0.6 + Math.random() * 0.7;
    df.exciteAt(body.x, body.y, radius, strength);
  }
}

class RotatingLineBrush extends BaseBrush {
  constructor(lifetime, config, length = 200, speed = 0.03) {
    super(lifetime);
    this.cx = config.W / 2;
    this.cy = config.H / 2;
    this.length = length;
    this.angle = 0;
    this.speed = speed;
    this.phase = Math.random() * Math.PI * 2;
    this.segmentPhase = Math.random() * Math.PI * 2;
  }

  update(dt, df) {
    this.updateAge();

    this.angle += this.speed;

    // slowly oscillate segment count between 2 and n
    const segDrift = 0.5 + 0.5 * Math.sin(this.segmentPhase + this.age * 0.3);
    const segments = Math.floor(2 + segDrift * 48); 
    const half = this.length / 2;
    const cosA = Math.cos(this.angle);
    const sinA = Math.sin(this.angle);

    // line endpoints rotating around center
    const x1 = this.cx + cosA * half;
    const y1 = this.cy + sinA * half;
    const x2 = this.cx - cosA * half;
    const y2 = this.cy - sinA * half;

    // draw along the line
    for (let i = 0; i <= segments; i++) {
      const t = i / segments;
      const x = x1 + (x2 - x1) * t;
      const y = y1 + (y2 - y1) * t;

      const radius = 3 + Math.random() * 3;
      const strength = 0.5 + 0.5 * Math.sin(this.phase + this.angle + t * Math.PI * 2);
      df.exciteAt(x, y, radius, strength);
    }
  }
}

class LineShape {
  constructor(config, length = 200) {
    this.cx = config.W / 2;
    this.cy = config.H / 2;
    this.length = length;
    this.vertices = [
      [this.cx - this.length / 2, this.cy],
      [this.cx + this.length / 2, this.cy],
    ];
  }

  getVertices() {
    return this.vertices.map(([x, y]) => [x, y]);
  }
}


class LissajousBrush extends BaseBrush {
  constructor(lifetime, cx, cy, radius = 180, freqX = 2, freqY = 3, speed = 0.02) {
    super(lifetime);
    this.cx = cx;
    this.cy = cy;
    this.radius = radius;
    this.freqX = freqX;
    this.freqY = freqY;
    this.speed = speed;
    this.t = Math.random() * Math.PI * 2; // random phase offset
    this.phaseShift = Math.random() * Math.PI * 2; // for richer variation
  }

  update(dt, df) {
    this.updateAge();
    this.t += this.speed;

    const x = this.cx + this.radius * Math.sin(this.freqX * this.t + this.phaseShift);
    const y = this.cy + this.radius * Math.cos(this.freqY * this.t);

    const radius = 4 + Math.sin(this.t * 0.7) * 2;
    const strength = 0.6 + 0.4 * Math.sin(this.t * 2 + this.phaseShift);

    df.exciteAt(x, y, radius, strength);
  }
}

class ChaoticDuoBrush extends BaseBrush { // lorenz 
    constructor(lifetime, points=2000, dt=0.01, sigma=10, rho=28, beta=8/3, scale=5) {
        super(lifetime);
        this.points = points;
        this.dt = dt;
        this.sigma = sigma;
        this.rho = rho;
        this.beta = beta;
        this.scale = scale;

        // Initialize Lorenz points
        this.x = 0.1; this.y = 0; this.z = 0.1;
        this.t = 0;
        this.path = [];
        this.offsetX = config.W/2;
        this.offsetY = config.H/2;
    }

    update(dt, df) {
        this.age += 1 / 60;
        if (this.age > this.lifetime) return false; // signal expired
        // Advance the path one step
        const dx = this.sigma*(this.y - this.x) * this.dt;
        const dy = (this.x*(this.rho - this.z) - this.y) * this.dt;
        const dz = (this.x*this.y - this.beta*this.z) * this.dt;

        this.x += dx;
        this.y += dy;
        this.z += dz;

        const canvasX = this.offsetX + this.x * this.scale;
        const canvasY = this.offsetY + this.y * this.scale;

        this.path.push([canvasX, canvasY]);
        if (this.path.length > this.points) this.path.shift();

        // Draw current step
        this.draw([[canvasX, canvasY]], df);
        return true;
    }

    draw(path, df) {
        for (let i = 0; i < path.length; i++) {
            const [x, y] = path[i];
            const radius = Math.random() * 6 + 4;
            const strength = Math.random() * 1.2 + 0.3;
            df.exciteAt(x, y, radius, strength);
        }
    }
}
class TriangleBrush extends BaseBrush {
    constructor(lifetime, config, points = 120, speed = 0.02) {
        super(lifetime); 
        this.cx = config.W / 2;
        this.cy = config.H / 2;
        this.radius = Math.min(config.W, config.H) / 4;
        this.points = points;
        this.speed = speed;
        this.angle = 0;
    }

    update(dt, df) {
        this.updateAge();
        
        this.angle += this.speed;
        // Calculate 3 triangle vertices rotated by current angle
        const a1 = this.angle;
        const a2 = this.angle + (2 * Math.PI / 3);
        const a3 = this.angle + (4 * Math.PI / 3);

        const x1 = this.cx + Math.cos(a1) * this.radius;
        const y1 = this.cy + Math.sin(a1) * this.radius;
        const x2 = this.cx + Math.cos(a2) * this.radius;
        const y2 = this.cy + Math.sin(a2) * this.radius;
        const x3 = this.cx + Math.cos(a3) * this.radius;
        const y3 = this.cy + Math.sin(a3) * this.radius;

        // Option 1: excite the three points
        df.exciteAt(x1, y1, 6, 1.0);
        df.exciteAt(x2, y2, 6, 1.0);
        df.exciteAt(x3, y3, 6, 1.0);

        // Option 2 (optional): excite along triangle edges for solid shape
        this.drawEdge(df, x1, y1, x2, y2);
        this.drawEdge(df, x2, y2, x3, y3);
        this.drawEdge(df, x3, y3, x1, y1);
    }

    drawEdge(df, x1, y1, x2, y2) {
        const steps = 20;
        for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            const x = x1 + (x2 - x1) * t;
            const y = y1 + (y2 - y1) * t;
            df.exciteAt(x, y, 3, 0.6);
        }
    }
}

// --- Shape: defines geometry ---
class TriangleShape {
    constructor(config) {
        this.cx = config.W / 2;
        this.cy = config.H / 2;
        this.radius = Math.min(config.W, config.H) / 4;
        this.vertices = this.computeVertices();
    }

  computeVertices() {
    const verts = [];
    for (let i = 0; i < 3; i++) {
      const angle = i * (2 * Math.PI / 3);
      const x = this.cx + Math.cos(angle) * this.radius;
      const y = this.cy + Math.sin(angle) * this.radius;
      verts.push([x, y]);
    }
    return verts;
  }

  getVertices() {
    return this.vertices.map(v => [...v]); // return a copy to avoid mutation
  }
}

class StarShape {
    constructor(config, points = 5) {
        this.cx = config.W / 2;
        this.cy = config.H / 2;
        this.radiusOuter = Math.min(config.W, config.H) / 4;
        this.radiusInner = this.radiusOuter * 0.5; // inner points of star
        this.points = points;
        this.vertices = this.computeVertices();
    }

    computeVertices() {
        const verts = [];
        const total = this.points * 2; // outer + inner
        for (let i = 0; i < total; i++) {
            const angle = i * (Math.PI / this.points); // π / points = half angle step
            const r = (i % 2 === 0) ? this.radiusOuter : this.radiusInner;
            const x = this.cx + Math.cos(angle) * r;
            const y = this.cy + Math.sin(angle) * r;
            verts.push([x, y]);
        }
        return verts;
    }

    getVertices() {
        return this.vertices.map(v => [...v]); // return a copy
    }
}

// --- Motion: defines how angle (and possibly position) changes over time ---
class RotatingMotion {
    constructor(speed = 0.02, initialAngle = 0) {
        this.speed = speed;
        this.angle = initialAngle;
    }
    update(vertices) {
        this.angle += this.speed;

        // Compute rotation around shape’s center
        // Find centroid first
        const cx = vertices.reduce((a, [x]) => a + x, 0) / vertices.length;
        const cy = vertices.reduce((a, [_, y]) => a + y, 0) / vertices.length;

        const cosA = Math.cos(this.angle);
        const sinA = Math.sin(this.angle);

        // Rotate each vertex about the centroid
        return vertices.map(([x, y]) => {
            const dx = x - cx;
            const dy = y - cy;
            const rx = cx + dx * cosA - dy * sinA;
            const ry = cy + dx * sinA + dy * cosA;
            return [rx, ry];
        });
    }
}

// --- Brush: owns shape and motion, paints into Dreamflow ---
class ShapeBrush extends BaseBrush {
    constructor(lifetime, shape, motion) {
        super(lifetime);
        this.shape = shape;
        this.motion = motion;
    }
    update(dt, df) {
        this.updateAge();
        //let verts = this.shape.getVertices();
        const verts = this.motion.update(this.shape.getVertices());
        //verts = this.shape.getVertices(angle);
        this.paint(df, verts);
    }
    paint(df, verts) {
        // Excite vertices
        for ( const [x, y] of verts ) {
            df.exciteAt(x, y, 6, 1.0);
        }

        // Excite edges — automatically loop back to the first vertex
        for ( let i = 0; i < verts.length; i++ ) {
            const [x1, y1] = verts[i];
            const [x2, y2] = verts[(i + 1) % verts.length]; // wraps around
            const steps = 20;
            for ( let s = 0; s <= steps; s++ ) {
                const t = s / steps;
                const x = x1 + (x2 - x1) * t;
                const y = y1 + (y2 - y1) * t;
                df.exciteAt(x, y, 3, 0.6);
            }
        }
    }
}
class RectangleShape {
  constructor(config, width, height) {
    this.cx = config.W / 2;
    this.cy = config.H / 2;
    this.width = width;
    this.height = height;
    this.vertices = this.computeVertices();
  }


  computeVertices() {
    const hw = this.width / 2;
    const hh = this.height / 2;

    // Unrotated rectangle corners relative to center
    return [
      [this.cx - hw, this.cy - hh],
      [this.cx + hw, this.cy - hh],
      [this.cx + hw, this.cy + hh],
      [this.cx - hw, this.cy + hh],
    ];
  }
  getVertices() {
    // Return a shallow copy to avoid mutation
    return this.vertices.map(([x, y]) => [x, y]);
  }
}
class WobbleMotion {
  constructor({ amp = 6, freq = 0.002, phaseSpread = Math.PI * 2 } = {}) {
    this.amp = amp;             // how far vertices wobble
    this.freq = freq;           // how fast the wobble oscillates
    this.phaseSpread = phaseSpread; // ensures vertices move differently
    this.startTime = performance.now();
  }

  update(vertices) {
    const t = (performance.now() - this.startTime) * this.freq;

    // return new set of wobbled vertices
    return vertices.map(([x, y], i) => {
      const phase = i * this.phaseSpread / vertices.length;
      const dx = Math.sin(t + phase) * this.amp;
      const dy = Math.cos(t * 1.1 + phase * 0.7) * this.amp * 0.8;
      return [x + dx, y + dy];
    });
  }
}
class BrushScheduler {
    constructor(brushes, nb) {
        this.brushes = brushes;
        this.nullBrush = nb;
        this.current = 0;
        this.isResting = false;
    }
    update(dt, df) {
// currently resting?
    if (this.isResting) {
      if (this.nullBrush.expired()) {
        this.nullBrush.reset();
        this.isResting = false;
      } else {
        this.nullBrush.update();
        return;
      }
    }

    // otherwise, run the active brush
    const brush = this.brushes[this.current];
    brush.update(dt, df);

    if (brush.expired()) {
      brush.reset();
      this.current = (this.current + 1) % this.brushes.length;
      this.isResting = true; // trigger a short null pause
    }
    }
}

class SpinMotion {
  constructor(speed = 0.02) {
    this.time = 0;        // internal spin timer
    this.speed = speed;    // how fast it “spins”
  }

  update(vertices) {
    this.time += this.speed;

    // Compute scale factor for X coordinate (0.5 → narrow, 1 → full width)
    const scale = 0.5 + 0.5 * Math.sin(this.time);

    const cx = vertices.reduce((sum, v) => sum + v[0], 0) / vertices.length;

    // Return new vertices with X scaled around center
    return vertices.map(([x, y]) => [
      cx + (x - cx) * scale,
      y
    ]);
  }
}

const brushes = [
    new ShapeBrush(16, new LineShape(config, 200), new RotatingMotion(0.03)),
    new ShapeBrush(16, new RectangleShape(config, 100, 100), new SpinMotion(0.02)),
    new ShapeBrush(16, new StarShape(config), new WobbleMotion()), //RotatingMotion(0.03)),
    new ShapeBrush(6, new TriangleShape(config), new RotatingMotion(0.02)),
    //new TriangleBrush(8, config, 120, 0.03),
    new RotatingLineBrush(15, config, 250, 0.04),
    new ChaoticDuoBrush(5),
    new LissajousBrush(6, config.W/2, config.H/2, 80, 5, 7, 0.002),
    new Brush(6, spiralPath(config.W/2, config.H/2, Math.min(config.W,config.H)/3, 3, 200)),
    new Brush(7, wavePath(config.W/2, config.H/2, Math.min(config.W,config.H)/3, 0.05, 200))
];
const scheduler = new BrushScheduler(brushes, new NullBrush());
dreamFlow.addScheduler(scheduler);



  // UI wiring
  btnPause.addEventListener('click', ()=>{
    running = !running;
    btnPause.textContent = running ? 'Pause' : 'Resume';
    if (running) { lastFrame = performance.now(); requestAnimationFrame(loop); }
  });
  btnSeed.addEventListener('click', ()=> seedRandom(1.2));
  btnClear.addEventListener('click', ()=> clearAll());
  applyGridBtn.addEventListener('click', ()=>{
    const newW = parseInt(gridWIn.value,10) || config.W;
    const newH = parseInt(gridHIn.value,10) || config.H;
    config.W = clamp(newW, 40, 960);
    config.H = clamp(newH, 24, 540);
    alloc();
    resizeCanvas();
  });

  diffRange.addEventListener('input', ()=> { config.diffusion = parseFloat(diffRange.value)/100; diffVal.textContent = config.diffusion.toFixed(3); });
  advRange.addEventListener('input', ()=> { config.advection = parseFloat(advRange.value)/100; advVal.textContent = config.advection.toFixed(3); });
  dampRange.addEventListener('input', ()=> { config.damping = parseFloat(dampRange.value)/1000; dampVal.textContent = config.damping.toFixed(4); });
  excRange.addEventListener('input', ()=> { config.excitationRate = parseFloat(excRange.value); excVal.textContent = config.excitationRate.toFixed(1); });

  // pointer painting
  let painting = false;
  function pointerToGrid(clientX, clientY){
    const r = canvas.getBoundingClientRect();
    const gx = (clientX - r.left) / r.width * config.W;
    const gy = (clientY - r.top)  / r.height * config.H;
    return [gx, gy];
  }
  canvas.addEventListener('mousedown', e => { painting = true; const [gx,gy] = pointerToGrid(e.clientX, e.clientY); dreamFlow.exciteAt(gx, gy, Math.max(config.W/32,6), 1.5); });
  window.addEventListener('mouseup', ()=> painting = false);
  window.addEventListener('mousemove', e => { if(!painting) return; const [gx,gy] = pointerToGrid(e.clientX, e.clientY); dreamFlow.exciteAt(gx, gy, Math.max(config.W/48,4), 0.9); });
  canvas.addEventListener('touchstart', e => { e.preventDefault(); painting = true; const t = e.touches[0]; const [gx,gy] = pointerToGrid(t.clientX, t.clientY); exciteAt(gx, gy, Math.max(W/32,6), 1.8); }, {passive:false});
  canvas.addEventListener('touchmove', e => { e.preventDefault(); if(!painting) return; const t = e.touches[0]; const [gx,gy] = pointerToGrid(t.clientX, t.clientY); exciteAt(gx, gy, Math.max(W/48,4), 1.0); }, {passive:false});
  canvas.addEventListener('touchend', e => { painting = false; }, {passive:false});

// runtime
let lastFrame = performance.now();
let fpsTime = performance.now();
let frameCount = 0;

// top-level loop
function loop(now) {
    if ( ! dreamFlow.running ) return;
    const dt = Math.max(1, now - lastFrame);
    lastFrame = now;
    dreamFlow.update(dt, offCtx, ctx);
    // fps tracking
    frameCount++;
    const tNow = performance.now();
    if ( tNow - fpsTime >= 500 ) {
        const fps = Math.round(frameCount / ((tNow - fpsTime)/1000));
        fpsLabel.textContent = fps + ' fps';
        fpsTime = tNow;
        frameCount = 0;
    }
    requestAnimationFrame(loop);
}

  // init
function init(){
    resizeCanvas();
    diffVal.textContent = config.diffusion.toFixed(3);
    advVal.textContent = config.advection.toFixed(3);
    dampVal.textContent = config.damping.toFixed(4);
    excVal.textContent = config.excitationRate.toFixed(1);
    requestAnimationFrame(loop);
}
window.addEventListener('resize', resizeCanvas);
init();

  // expose for tinkering
window.Dreamflow = {
  exciteAt: dreamFlow.exciteAt.bind(dreamFlow),
  seedRandom: dreamFlow.seedRandom.bind(dreamFlow),
  clearAll: dreamFlow.clearAll.bind(dreamFlow),
  getParams: () => ({
    W,
    H,
    diffusion,
    advection,
    damping,
    excitationRate
  })
};

})();
</script>
</body>
</html>
